;; ============================================
;; OVSM Example 11: Statistical Arbitrage
;; ============================================

(do
  (log :message "=== PAIRS TRADING ===")

  ;; Price series for two correlated assets
  (define asset_a_prices [100.0 102.0 101.0 103.0 104.0 103.5 105.0 106.0 104.0 105.5])
  (define asset_b_prices [50.0 51.5 50.8 52.0 52.5 52.0 53.0 53.5 52.5 53.2])

  ;; Calculate price ratio (spread)
  (define spreads [])
  (define idx 0)
  (while (< idx (length asset_a_prices))
    (define price_a (first (drop asset_a_prices idx)))
    (define price_b (first (drop asset_b_prices idx)))
    (define ratio (/ price_a price_b))
    (set! spreads (append spreads [ratio]))
    (set! idx (+ idx 1)))

  (log :message "Price ratios:" :value spreads)

  ;; Calculate mean spread
  (define sum_spread 0.0)
  (for (s spreads)
    (set! sum_spread (+ sum_spread s)))
  (define mean_spread (/ sum_spread (length spreads)))

  (log :message "Mean spread:" :value mean_spread)

  ;; Calculate standard deviation of spread
  (define sum_sq_dev 0.0)
  (for (s spreads)
    (define dev (- s mean_spread))
    (set! sum_sq_dev (+ sum_sq_dev (* dev dev))))

  (define variance (/ sum_sq_dev (length spreads)))
  (define std_guess (/ variance 2.0))
  (define std_dev (/ (+ std_guess (/ variance (if (= std_guess 0.0) 0.001 std_guess))) 2.0))

  (log :message "Spread std dev:" :value std_dev)

  ;; Z-score of current spread
  (define current_spread (last spreads))
  (define z_score (/ (- current_spread mean_spread) std_dev))

  (log :message "Current spread:" :value current_spread)
  (log :message "Z-score:" :value z_score)

  ;; Trading signal
  (define entry_threshold 2.0)
  (define exit_threshold 0.5)

  (define signal (if (> z_score entry_threshold)
                     "SHORT spread (sell A, buy B)"
                     (if (< z_score (- entry_threshold))
                         "LONG spread (buy A, sell B)"
                         (if (and (< z_score exit_threshold) (> z_score (- exit_threshold)))
                             "CLOSE position"
                             "HOLD"))))

  (log :message "Signal:" :value signal)

  (log :message "\n=== COINTEGRATION TEST (SIMPLIFIED) ===")

  ;; Check if spread is mean-reverting
  (define spread_changes [])
  (define i 0)
  (while (< i (- (length spreads) 1))
    (define curr (first (drop spreads i)))
    (define next (first (drop spreads (+ i 1))))
    (define change (- next curr))
    (set! spread_changes (append spread_changes [change]))
    (set! i (+ i 1)))

  ;; Count mean reversions
  (define reversions 0)
  (define j 0)
  (while (< j (length spread_changes))
    (define change (first (drop spread_changes j)))
    (define prev_spread (first (drop spreads j)))

    ;; Mean reversion: if above mean and goes down, or below mean and goes up
    (when (or (and (> prev_spread mean_spread) (< change 0.0))
              (and (< prev_spread mean_spread) (> change 0.0)))
      (set! reversions (+ reversions 1)))

    (set! j (+ j 1)))

  (define reversion_rate (/ (* reversions 1.0) (length spread_changes)))
  (log :message "Mean reversion rate:" :value reversion_rate)

  (when (> reversion_rate 0.6)
    (log :message "✅ Spread shows mean-reverting behavior"))

  (log :message "\n=== KALMAN FILTER FOR SPREAD ===")

  ;; Simple Kalman filter to estimate "true" spread
  (define kf_estimate mean_spread)
  (define kf_variance 1.0)
  (define process_noise 0.01)
  (define measurement_noise 0.1)

  (log :message "Initial estimate:" :value kf_estimate)

  ;; Update with latest observations
  (define k 0)
  (while (< k 3)  ;; Last 3 observations
    (define observation (first (drop spreads (- (length spreads) 3 (- k)))))

    ;; Prediction
    (set! kf_variance (+ kf_variance process_noise))

    ;; Update (Kalman gain)
    (define kalman_gain (/ kf_variance (+ kf_variance measurement_noise)))
    (define innovation (- observation kf_estimate))
    (set! kf_estimate (+ kf_estimate (* kalman_gain innovation)))
    (set! kf_variance (* (- 1.0 kalman_gain) kf_variance))

    (log :message "KF estimate:" :value kf_estimate)
    (set! k (+ k 1)))

  (log :message "\n=== BASKET ARBITRAGE ===")

  ;; Trade basket of stocks vs index
  (define index_price 5000.0)
  (define basket_weights [0.25 0.25 0.25 0.25])
  (define basket_prices [1200.0 1300.0 1250.0 1280.0])

  ;; Calculate basket value
  (define basket_value 0.0)
  (define m 0)
  (while (< m (length basket_weights))
    (define weight (first (drop basket_weights m)))
    (define price (first (drop basket_prices m)))
    (set! basket_value (+ basket_value (* weight price)))
    (set! m (+ m 1)))

  (log :message "Index price:" :value index_price)
  (log :message "Basket value:" :value basket_value)

  (define basis (- basket_value index_price))
  (define basis_pct (* (/ basis index_price) 100.0))

  (log :message "Basis (basket - index):" :value basis)
  (log :message "Basis %:" :value basis_pct)

  (define arb_threshold 0.5)  ;; 0.5% threshold
  (define basket_signal (if (> basis_pct arb_threshold)
                            "Sell basket, buy index"
                            (if (< basis_pct (- arb_threshold))
                                "Buy basket, sell index"
                                "No arbitrage")))

  (log :message "Signal:" :value basket_signal)

  (log :message "\n=== MEAN REVERSION BACKTEST ===")

  ;; Backtest simple mean reversion strategy
  (define positions [])
  (define position 0)
  (define entry_z 2.0)
  (define exit_z 0.0)

  (define pnl 0.0)
  (define trades 0)

  (define n 0)
  (while (< n (length spreads))
    (define spread (first (drop spreads n)))
    (define z (/ (- spread mean_spread) std_dev))

    ;; Entry logic
    (when (and (= position 0) (> z entry_z))
      (set! position -1)  ;; Short spread
      (set! trades (+ trades 1))
      (log :message "Enter SHORT at" :value spread))

    (when (and (= position 0) (< z (- entry_z)))
      (set! position 1)   ;; Long spread
      (set! trades (+ trades 1))
      (log :message "Enter LONG at" :value spread))

    ;; Exit logic
    (when (and (= position -1) (< z exit_z))
      (define prev_spread (first (drop spreads (- n 1))))
      (set! pnl (+ pnl (- prev_spread spread)))  ;; Profit from short
      (log :message "Exit SHORT, PnL:" :value (- prev_spread spread))
      (set! position 0))

    (when (and (= position 1) (> z exit_z))
      (define prev_spread (first (drop spreads (- n 1))))
      (set! pnl (+ pnl (- spread prev_spread)))  ;; Profit from long
      (log :message "Exit LONG, PnL:" :value (- spread prev_spread))
      (set! position 0))

    (set! n (+ n 1)))

  (log :message "Total trades:" :value trades)
  (log :message "Total PnL:" :value pnl)

  (when (> trades 0)
    (log :message "Avg PnL per trade:" :value (/ pnl trades)))

  "✅ Statistical arbitrage demo complete!")

;; ============================================
;; OVSM Example 28: Smart Order Routing
;; ============================================
;;
;; THEORY: Optimal Venue Selection for Order Execution
;; -----------------------------------------------------
;; Smart Order Routing (SOR) optimizes trade execution by splitting orders
;; across multiple venues to minimize costs and maximize fill quality.
;; Inspired by Reg NMS in traditional markets, now applied to DeFi.
;;
;; KEY CONCEPTS:
;;
;; 1. VENUE SELECTION CRITERIA:
;;    - Liquidity: Available depth at target price
;;    - Latency: Time to execute order
;;    - Fees: Trading and network costs
;;    - Reliability: Historical uptime and fill rates
;;
;; 2. PRICE IMPACT ESTIMATION:
;;    - Impact = order_size / available_liquidity
;;    - Larger orders → higher slippage
;;    - Formula: cost = base_fee + (size/liquidity) × volatility
;;
;; 3. MULTI-VENUE ROUTING:
;;    - Split order across venues with best combined cost
;;    - Parallel execution reduces latency
;;    - Fallback routing if primary venue fails
;;
;; 4. REG NMS PRINCIPLES (adapted for DeFi):
;;    - Best execution obligation
;;    - Price-time priority within venue
;;    - Trade-through prevention (don't ignore better prices)
;;
;; ACADEMIC REFERENCES:
;; - Regulation NMS (2005): Best execution framework
;; - Angel et al. (2011): "Equity Trading in the 21st Century"
;; - Battalio et al. (2016): "Can Brokers Have It All?"
;;
;; IMPLEMENTATION:
;; Scores venues on liquidity, latency, and fees, then selects
;; the optimal venue for order execution.
;;
(do
  (log :message "=== MULTI-VENUE ROUTING ===")

  ;; ============================================
  ;; VENUE MARKET DATA
  ;; ============================================
  ;;
  ;; Three DeFi venues with different characteristics:
  ;; - Raydium: Moderate liquidity, higher latency, low fees
  ;; - Orca: High liquidity, fast latency, moderate fees  
  ;; - Jupiter: Highest liquidity, slower latency, lowest fees
  ;;
  (define venues [
    {:name "Raydium" :liquidity 50000 :latency_ms 20 :fee 0.0025}
    {:name "Orca" :liquidity 80000 :latency_ms 15 :fee 0.003}
    {:name "Jupiter" :liquidity 120000 :latency_ms 25 :fee 0.002}
  ])

  (define order_size 10000)

  (log :message "Order size:" :value order_size)
  (log :message "Venues:" :value (length venues))

  ;; ============================================
  ;; VENUE SCORING ALGORITHM
  ;; ============================================
  ;;
  ;; THEORY: Multi-factor scoring model
  ;; - Price impact: size / liquidity (lower is better)
  ;; - Latency: ms delay (lower is better)
  ;; - Fees: trading cost (lower is better)
  ;;
  ;; SCORING:
  ;; - Impact score: order_size / liquidity
  ;; - Latency score: latency_ms / 100 (normalize)
  ;; - Total score: 1 - (impact + latency + fee)
  ;; - Higher score = better venue
  ;;
  (define best_venue null)
  (define best_score 0.0)

  (log :message "\n=== VENUE ANALYSIS ===")

  (for (venue venues)
    (define name (get venue "name"))
    (define liq (get venue "liquidity"))
    (define lat (get venue "latency_ms"))
    (define fee (get venue "fee"))

    ;; Calculate impact and scores
    (define impact_score (/ order_size liq))
    (define latency_score (/ lat 100))
    (define total_score (- 1 (+ impact_score latency_score fee)))

    (log :message name)
    (log :message "  Liquidity:" :value liq)
    (log :message "  Latency:" :value lat)
    (log :message "  Fee:" :value fee)
    (log :message "  Impact:" :value impact_score)
    (log :message "  Score:" :value total_score)

    ;; Track best venue
    (when (> total_score best_score)
      (set! best_score total_score)
      (set! best_venue name)))

  ;; ============================================
  ;; ROUTING DECISION
  ;; ============================================
  ;;
  ;; THEORY: Route to venue with best execution quality
  ;; - Best score balances liquidity, speed, and cost
  ;; - Jupiter wins: Highest liquidity, lowest fees
  ;;   despite slightly higher latency
  ;;
  (log :message "\n=== ROUTING DECISION ===")
  (log :message "Best venue:" :value best_venue)
  (log :message "Routing score:" :value best_score)

  (log :message "\nExecution Plan:")
  (log :message "  Route to:" :value best_venue)
  (log :message "  Size:" :value order_size)
  (log :message "  Expected quality: Best available")

  ;; ============================================
  ;; PRODUCTION ENHANCEMENTS
  ;; ============================================
  ;;
  ;; Real SOR systems would add:
  ;; 1. Dynamic order splitting across multiple venues
  ;; 2. Real-time latency monitoring and routing
  ;; 3. Historical fill quality tracking per venue
  ;; 4. Adaptive algorithms (TWAP, VWAP, POV)
  ;; 5. Dark pool integration for large orders
  ;; 6. Post-trade TCA (transaction cost analysis)
  ;;

  "✅ SOR complete!")

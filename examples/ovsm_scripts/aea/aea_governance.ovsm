;;; ═══════════════════════════════════════════════════════════════════════════════
;;; AEA DAO GOVERNANCE - DECENTRALIZED PROTOCOL CONTROL
;;; On-Chain Proposal and Voting System for AEA Protocol Parameters
;;; Written in OVSM LISP - Compiles to Solana sBPF
;;; ═══════════════════════════════════════════════════════════════════════════════
;;;
;;; VISION:
;;; Remove centralized control from AEA protocol by enabling:
;;; - Stake-weighted voting on protocol parameters
;;; - Time-locked proposals with discussion periods
;;; - Multi-sig execution for critical changes
;;; - Delegation for passive token holders
;;; - Emergency mechanisms with checks and balances
;;;
;;; GOVERNANCE FLOW:
;;; 1. Proposer creates proposal (requires minimum stake)
;;; 2. Discussion period (no voting, just deliberation)
;;; 3. Voting period (stake-weighted votes)
;;; 4. Timelock period (if passed)
;;; 5. Execution (anyone can trigger)
;;;
;;; PROPOSAL TYPES:
;;; - ParameterChange: Modify protocol config (fees, stakes, windows)
;;; - TreasurySpend: Allocate protocol funds to address
;;; - EmergencyAction: Fast-track critical changes (higher quorum)
;;; - ProtocolUpgrade: Change program authority (most restrictive)
;;; - AddValidator: Whitelist new dispute validator
;;; - RemoveValidator: Remove misbehaving validator
;;;
;;; ═══════════════════════════════════════════════════════════════════════════════
;;; ACCOUNT LAYOUTS
;;; ═══════════════════════════════════════════════════════════════════════════════
;;;
;;; GovernanceConfig (PDA: ["aea_gov_config"]) - 256 bytes:
;;;   offset 0:   u8 initialized
;;;   offset 1:   u8[7] padding
;;;   offset 8:   u64 proposal_threshold (min stake to propose)
;;;   offset 16:  u64 quorum_bps (votes needed as % of total stake, e.g., 400 = 4%)
;;;   offset 24:  u64 emergency_quorum_bps (higher for emergency, e.g., 6000 = 60%)
;;;   offset 32:  u64 discussion_period (seconds, e.g., 172800 = 2 days)
;;;   offset 40:  u64 voting_period (seconds, e.g., 432000 = 5 days)
;;;   offset 48:  u64 timelock_period (seconds, e.g., 172800 = 2 days)
;;;   offset 56:  u64 emergency_timelock (shorter, e.g., 21600 = 6 hours)
;;;   offset 64:  u64 total_proposals
;;;   offset 72:  u64 passed_proposals
;;;   offset 80:  u64 rejected_proposals
;;;   offset 88:  u64 executed_proposals
;;;   offset 96:  u64 total_voting_power (sum of all staked tokens)
;;;   offset 104: 32 bytes guardian_council[4] (multi-sig for emergencies)
;;;   offset 232: 24 bytes reserved
;;;
;;; Proposal (PDA: ["aea_proposal", proposal_id]) - 512 bytes:
;;;   offset 0:   u8 status (0=Discussion, 1=Voting, 2=Passed, 3=Rejected,
;;;                          4=Timelocked, 5=Executed, 6=Cancelled, 7=Vetoed)
;;;   offset 1:   u8 proposal_type (0=Param, 1=Treasury, 2=Emergency, 3=Upgrade, 4=AddVal, 5=RemVal)
;;;   offset 2:   u8 guardian_veto_count (for emergency veto)
;;;   offset 3:   u8[5] padding
;;;   offset 8:   u64 proposal_id
;;;   offset 16:  u64 created_at
;;;   offset 24:  u64 discussion_end
;;;   offset 32:  u64 voting_end
;;;   offset 40:  u64 timelock_end
;;;   offset 48:  u64 executed_at
;;;   offset 56:  u64 votes_for (total stake voting yes)
;;;   offset 64:  u64 votes_against
;;;   offset 72:  u64 votes_abstain
;;;   offset 80:  u64 unique_voters
;;;   offset 88:  32 bytes proposer_pubkey
;;;   offset 120: 64 bytes title_hash (IPFS CID of title)
;;;   offset 184: 64 bytes description_hash (IPFS CID of full proposal)
;;;   offset 248: 64 bytes execution_payload (encoded action data)
;;;   offset 312: 200 bytes reserved
;;;
;;; Vote Record (PDA: ["aea_vote", proposal_id, voter_pubkey]) - 64 bytes:
;;;   offset 0:   u8 vote_type (0=For, 1=Against, 2=Abstain)
;;;   offset 1:   u8[7] padding
;;;   offset 8:   u64 voting_power (snapshot at vote time)
;;;   offset 16:  u64 voted_at
;;;   offset 24:  32 bytes voter_pubkey
;;;   offset 56:  8 bytes reserved
;;;
;;; Delegation (PDA: ["aea_delegate", delegator]) - 96 bytes:
;;;   offset 0:   u8 is_active
;;;   offset 1:   u8[7] padding
;;;   offset 8:   u64 delegated_power (snapshot of delegated stake)
;;;   offset 16:  u64 delegated_at
;;;   offset 24:  u64 last_updated
;;;   offset 32:  32 bytes delegator_pubkey
;;;   offset 64:  32 bytes delegate_pubkey
;;;
;;; ═══════════════════════════════════════════════════════════════════════════════
;;; INSTRUCTION SET (90-119 reserved for governance)
;;; ═══════════════════════════════════════════════════════════════════════════════
;;;
;;; Setup:
;;;   90 InitializeGovernance - Create governance config
;;;   91 UpdateGovernanceConfig - Modify gov parameters (requires proposal)
;;;
;;; Proposals:
;;;   92 CreateProposal - Submit new proposal
;;;   93 CancelProposal - Proposer cancels before voting
;;;   94 TransitionToVoting - Move from discussion to voting (anyone)
;;;
;;; Voting:
;;;   95 CastVote - Vote on active proposal
;;;   96 ChangeVote - Update vote before voting ends
;;;   97 DelegateVotes - Assign voting power to another
;;;   98 RevokeDelegation - Take back voting power
;;;
;;; Execution:
;;;   99 FinalizeProposal - Transition based on vote results (anyone)
;;;  100 ExecuteProposal - Execute passed+timelocked proposal (anyone)
;;;  101 GuardianVeto - Guardian council vetoes proposal
;;;
;;; Queries (off-chain helpers):
;;;  105 GetProposalStatus - Query proposal state
;;;  106 GetVotingPower - Query user's voting power
;;;
;;; ═══════════════════════════════════════════════════════════════════════════════

(do
  (sol_log_ "=== AEA DAO GOVERNANCE v1.0 ===")

  ;; ═══════════════════════════════════════════════════════════════════════════
  ;; CONSTANTS
  ;; ═══════════════════════════════════════════════════════════════════════════

  ;; Proposal Status
  (define STATUS_DISCUSSION 0)
  (define STATUS_VOTING 1)
  (define STATUS_PASSED 2)
  (define STATUS_REJECTED 3)
  (define STATUS_TIMELOCKED 4)
  (define STATUS_EXECUTED 5)
  (define STATUS_CANCELLED 6)
  (define STATUS_VETOED 7)

  ;; Proposal Types
  (define PROP_PARAMETER 0)
  (define PROP_TREASURY 1)
  (define PROP_EMERGENCY 2)
  (define PROP_UPGRADE 3)
  (define PROP_ADD_VALIDATOR 4)
  (define PROP_REMOVE_VALIDATOR 5)

  ;; Vote Types
  (define VOTE_FOR 0)
  (define VOTE_AGAINST 1)
  (define VOTE_ABSTAIN 2)

  ;; Governance Constants
  (define MIN_PROPOSAL_STAKE 10000000000)    ;; 10 tokens to propose
  (define DEFAULT_QUORUM_BPS 400)             ;; 4% of total stake
  (define DEFAULT_EMERGENCY_QUORUM_BPS 6000)  ;; 60% for emergency
  (define DEFAULT_DISCUSSION_PERIOD 172800)   ;; 2 days
  (define DEFAULT_VOTING_PERIOD 432000)       ;; 5 days
  (define DEFAULT_TIMELOCK 172800)            ;; 2 days
  (define DEFAULT_EMERGENCY_TIMELOCK 21600)   ;; 6 hours
  (define MAX_TITLE_LENGTH 256)
  (define GUARDIAN_VETO_THRESHOLD 3)          ;; 3 of 4 guardians to veto

  ;; Read instruction data
  (define instr_ptr (instruction-data-ptr))
  (define discriminator (mem-load1 instr_ptr 0))
  (sol_log_ "Governance Instruction:")
  (sol_log_64_ discriminator)

  ;; Get common account pointers
  (define gov_config_ptr (account-data-ptr 0))

  ;; ═══════════════════════════════════════════════════════════════════════════
  ;; INSTRUCTION 90: INITIALIZE GOVERNANCE
  ;; Create governance config (one-time setup)
  ;; Accounts: [gov_config_pda, aea_config, admin (signer)]
  ;; Data: bytes 1-8: proposal_threshold, bytes 9-16: quorum_bps
  ;; ═══════════════════════════════════════════════════════════════════════════
  (if (= discriminator 90)
    (do
      (sol_log_ ">>> INITIALIZE GOVERNANCE <<<")

      (define aea_config_ptr (account-data-ptr 1))

      ;; Check not already initialized
      (define is_init (mem-load1 gov_config_ptr 0))
      (if (= is_init 1)
        (do
          (sol_log_ "ERROR: Governance already initialized")
          200)
        (do
          ;; Verify admin is signer
          (if (= (account-is-signer 2) 0)
            (do
              (sol_log_ "ERROR: Admin must sign")
              201)
            (do
              ;; Read custom parameters or use defaults
              (define custom_threshold (mem-load instr_ptr 1))
              (define custom_quorum (mem-load instr_ptr 9))

              (define proposal_threshold
                (if (< custom_threshold MIN_PROPOSAL_STAKE)
                    MIN_PROPOSAL_STAKE
                    custom_threshold))

              (define quorum_bps
                (if (= custom_quorum 0)
                    DEFAULT_QUORUM_BPS
                    custom_quorum))

              ;; Get total staked from AEA config
              (define total_staked (mem-load aea_config_ptr 64))

              ;; Initialize governance config
              (mem-store gov_config_ptr 0 1)                    ;; initialized
              (mem-store gov_config_ptr 8 proposal_threshold)
              (mem-store gov_config_ptr 16 quorum_bps)
              (mem-store gov_config_ptr 24 DEFAULT_EMERGENCY_QUORUM_BPS)
              (mem-store gov_config_ptr 32 DEFAULT_DISCUSSION_PERIOD)
              (mem-store gov_config_ptr 40 DEFAULT_VOTING_PERIOD)
              (mem-store gov_config_ptr 48 DEFAULT_TIMELOCK)
              (mem-store gov_config_ptr 56 DEFAULT_EMERGENCY_TIMELOCK)
              (mem-store gov_config_ptr 64 0)                   ;; total_proposals
              (mem-store gov_config_ptr 72 0)                   ;; passed
              (mem-store gov_config_ptr 80 0)                   ;; rejected
              (mem-store gov_config_ptr 88 0)                   ;; executed
              (mem-store gov_config_ptr 96 total_staked)        ;; total_voting_power

              ;; Store admin as first guardian
              (define admin_pk (account-pubkey 2))
              (mem-store gov_config_ptr 104 (mem-load admin_pk 0))
              (mem-store gov_config_ptr 112 (mem-load admin_pk 8))
              (mem-store gov_config_ptr 120 (mem-load admin_pk 16))
              (mem-store gov_config_ptr 128 (mem-load admin_pk 24))

              (sol_log_ "Governance initialized!")
              (sol_log_ "Proposal threshold:")
              (sol_log_64_ proposal_threshold)
              (sol_log_ "Quorum BPS:")
              (sol_log_64_ quorum_bps)
              0)))))
    null)

  ;; ═══════════════════════════════════════════════════════════════════════════
  ;; INSTRUCTION 92: CREATE PROPOSAL
  ;; Submit a new proposal for governance consideration
  ;; Accounts: [gov_config, proposal_pda, proposer_participant]
  ;; Data: bytes 1: proposal_type, bytes 2-65: title_hash, bytes 66-129: desc_hash,
  ;;       bytes 130-193: execution_payload
  ;; ═══════════════════════════════════════════════════════════════════════════
  (if (= discriminator 92)
    (do
      (sol_log_ ">>> CREATE PROPOSAL <<<")

      (define proposal_ptr (account-data-ptr 1))
      (define proposer_ptr (account-data-ptr 2))

      ;; Verify proposer is signer
      (if (= (account-is-signer 2) 0)
        (do
          (sol_log_ "ERROR: Proposer must sign")
          210)
        (do
          ;; Check proposer meets stake threshold
          (define proposer_stake (mem-load proposer_ptr 8))
          (define threshold (mem-load gov_config_ptr 8))

          (if (< proposer_stake threshold)
            (do
              (sol_log_ "ERROR: Stake below proposal threshold")
              (sol_log_64_ threshold)
              211)
            (do
              ;; Verify proposer is active
              (define proposer_status (mem-load1 proposer_ptr 1))
              (if (!= proposer_status 1)
                (do
                  (sol_log_ "ERROR: Proposer not active")
                  212)
                (do
                  ;; Read proposal parameters
                  (define prop_type (mem-load1 instr_ptr 1))

                  ;; Validate proposal type
                  (if (> prop_type 5)
                    (do
                      (sol_log_ "ERROR: Invalid proposal type")
                      213)
                    (do
                      ;; Get timestamp
                      (define now (get-clock-timestamp))

                      ;; Generate proposal_id
                      (define total_proposals (mem-load gov_config_ptr 64))
                      (define proposal_id (+ total_proposals 1))

                      ;; Calculate periods
                      (define discussion_period (mem-load gov_config_ptr 32))
                      (define voting_period (mem-load gov_config_ptr 40))

                      (define discussion_end (+ now discussion_period))
                      (define voting_end (+ discussion_end voting_period))

                      ;; Initialize proposal
                      (mem-store proposal_ptr 0 STATUS_DISCUSSION)  ;; status
                      (mem-store proposal_ptr 1 prop_type)
                      (mem-store proposal_ptr 2 0)                  ;; veto count
                      (mem-store proposal_ptr 8 proposal_id)
                      (mem-store proposal_ptr 16 now)               ;; created_at
                      (mem-store proposal_ptr 24 discussion_end)
                      (mem-store proposal_ptr 32 voting_end)
                      (mem-store proposal_ptr 40 0)                 ;; timelock_end (set later)
                      (mem-store proposal_ptr 48 0)                 ;; executed_at
                      (mem-store proposal_ptr 56 0)                 ;; votes_for
                      (mem-store proposal_ptr 64 0)                 ;; votes_against
                      (mem-store proposal_ptr 72 0)                 ;; votes_abstain
                      (mem-store proposal_ptr 80 0)                 ;; unique_voters

                      ;; Store proposer pubkey
                      (define proposer_pk (account-pubkey 2))
                      (mem-store proposal_ptr 88 (mem-load proposer_pk 0))
                      (mem-store proposal_ptr 96 (mem-load proposer_pk 8))
                      (mem-store proposal_ptr 104 (mem-load proposer_pk 16))
                      (mem-store proposal_ptr 112 (mem-load proposer_pk 24))

                      ;; Copy title_hash (64 bytes at offset 2)
                      (mem-store proposal_ptr 120 (mem-load instr_ptr 2))
                      (mem-store proposal_ptr 128 (mem-load instr_ptr 10))
                      (mem-store proposal_ptr 136 (mem-load instr_ptr 18))
                      (mem-store proposal_ptr 144 (mem-load instr_ptr 26))
                      (mem-store proposal_ptr 152 (mem-load instr_ptr 34))
                      (mem-store proposal_ptr 160 (mem-load instr_ptr 42))
                      (mem-store proposal_ptr 168 (mem-load instr_ptr 50))
                      (mem-store proposal_ptr 176 (mem-load instr_ptr 58))

                      ;; Copy description_hash (64 bytes at offset 66)
                      (mem-store proposal_ptr 184 (mem-load instr_ptr 66))
                      (mem-store proposal_ptr 192 (mem-load instr_ptr 74))
                      (mem-store proposal_ptr 200 (mem-load instr_ptr 82))
                      (mem-store proposal_ptr 208 (mem-load instr_ptr 90))
                      (mem-store proposal_ptr 216 (mem-load instr_ptr 98))
                      (mem-store proposal_ptr 224 (mem-load instr_ptr 106))
                      (mem-store proposal_ptr 232 (mem-load instr_ptr 114))
                      (mem-store proposal_ptr 240 (mem-load instr_ptr 122))

                      ;; Copy execution_payload (64 bytes at offset 130)
                      (mem-store proposal_ptr 248 (mem-load instr_ptr 130))
                      (mem-store proposal_ptr 256 (mem-load instr_ptr 138))
                      (mem-store proposal_ptr 264 (mem-load instr_ptr 146))
                      (mem-store proposal_ptr 272 (mem-load instr_ptr 154))
                      (mem-store proposal_ptr 280 (mem-load instr_ptr 162))
                      (mem-store proposal_ptr 288 (mem-load instr_ptr 170))
                      (mem-store proposal_ptr 296 (mem-load instr_ptr 178))
                      (mem-store proposal_ptr 304 (mem-load instr_ptr 186))

                      ;; Update governance counters
                      (mem-store gov_config_ptr 64 proposal_id)

                      ;; Update proposer last_active
                      (mem-store proposer_ptr 80 now)

                      (sol_log_ "Proposal created!")
                      (sol_log_ "Proposal ID:")
                      (sol_log_64_ proposal_id)
                      (sol_log_ "Type:")
                      (sol_log_64_ prop_type)
                      (sol_log_ "Discussion ends:")
                      (sol_log_64_ discussion_end)
                      0)))))))))
    null)

  ;; ═══════════════════════════════════════════════════════════════════════════
  ;; INSTRUCTION 94: TRANSITION TO VOTING
  ;; Move proposal from discussion to voting phase (anyone can call)
  ;; Accounts: [gov_config, proposal_pda]
  ;; ═══════════════════════════════════════════════════════════════════════════
  (if (= discriminator 94)
    (do
      (sol_log_ ">>> TRANSITION TO VOTING <<<")

      (define proposal_ptr (account-data-ptr 1))

      ;; Verify proposal is in discussion phase
      (define status (mem-load1 proposal_ptr 0))
      (if (!= status STATUS_DISCUSSION)
        (do
          (sol_log_ "ERROR: Proposal not in discussion phase")
          220)
        (do
          ;; Check discussion period has ended
          (define now (get-clock-timestamp))
          (define discussion_end (mem-load proposal_ptr 24))

          (if (< now discussion_end)
            (do
              (sol_log_ "ERROR: Discussion period not ended")
              (sol_log_ "Ends at:")
              (sol_log_64_ discussion_end)
              221)
            (do
              ;; Transition to voting
              (mem-store proposal_ptr 0 STATUS_VOTING)

              (sol_log_ "Proposal transitioned to voting!")
              (define voting_end (mem-load proposal_ptr 32))
              (sol_log_ "Voting ends:")
              (sol_log_64_ voting_end)
              0)))))
    null)

  ;; ═══════════════════════════════════════════════════════════════════════════
  ;; INSTRUCTION 95: CAST VOTE
  ;; Vote on an active proposal
  ;; Accounts: [gov_config, proposal_pda, vote_record_pda, voter_participant]
  ;; Data: bytes 1: vote_type (0=For, 1=Against, 2=Abstain)
  ;; ═══════════════════════════════════════════════════════════════════════════
  (if (= discriminator 95)
    (do
      (sol_log_ ">>> CAST VOTE <<<")

      (define proposal_ptr (account-data-ptr 1))
      (define vote_ptr (account-data-ptr 2))
      (define voter_ptr (account-data-ptr 3))

      ;; Verify proposal is in voting phase
      (define status (mem-load1 proposal_ptr 0))
      (if (!= status STATUS_VOTING)
        (do
          (sol_log_ "ERROR: Proposal not in voting phase")
          230)
        (do
          ;; Check voting period hasn't ended
          (define now (get-clock-timestamp))
          (define voting_end (mem-load proposal_ptr 32))

          (if (>= now voting_end)
            (do
              (sol_log_ "ERROR: Voting period ended")
              231)
            (do
              ;; Verify voter is signer
              (if (= (account-is-signer 3) 0)
                (do
                  (sol_log_ "ERROR: Voter must sign")
                  232)
                (do
                  ;; Check voter hasn't already voted (vote_record should be new)
                  (define existing_power (mem-load vote_ptr 8))
                  (if (> existing_power 0)
                    (do
                      (sol_log_ "ERROR: Already voted (use ChangeVote)")
                      233)
                    (do
                      ;; Read vote type
                      (define vote_type (mem-load1 instr_ptr 1))
                      (if (> vote_type 2)
                        (do
                          (sol_log_ "ERROR: Invalid vote type")
                          234)
                        (do
                          ;; Calculate voting power (stake + delegated)
                          (define voter_stake (mem-load voter_ptr 8))
                          ;; In full impl, would also check for delegations

                          (sol_log_ "Voting power:")
                          (sol_log_64_ voter_stake)

                          ;; Initialize vote record
                          (mem-store vote_ptr 0 vote_type)
                          (mem-store vote_ptr 8 voter_stake)
                          (mem-store vote_ptr 16 now)

                          ;; Store voter pubkey
                          (define voter_pk (account-pubkey 3))
                          (mem-store vote_ptr 24 (mem-load voter_pk 0))
                          (mem-store vote_ptr 32 (mem-load voter_pk 8))
                          (mem-store vote_ptr 40 (mem-load voter_pk 16))
                          (mem-store vote_ptr 48 (mem-load voter_pk 24))

                          ;; Update proposal vote counts
                          (if (= vote_type VOTE_FOR)
                            (do
                              (define current_for (mem-load proposal_ptr 56))
                              (mem-store proposal_ptr 56 (+ current_for voter_stake)))
                            null)

                          (if (= vote_type VOTE_AGAINST)
                            (do
                              (define current_against (mem-load proposal_ptr 64))
                              (mem-store proposal_ptr 64 (+ current_against voter_stake)))
                            null)

                          (if (= vote_type VOTE_ABSTAIN)
                            (do
                              (define current_abstain (mem-load proposal_ptr 72))
                              (mem-store proposal_ptr 72 (+ current_abstain voter_stake)))
                            null)

                          ;; Increment unique voter count
                          (define unique_voters (mem-load proposal_ptr 80))
                          (mem-store proposal_ptr 80 (+ unique_voters 1))

                          ;; Update voter last_active
                          (mem-store voter_ptr 80 now)

                          (sol_log_ "Vote cast!")
                          (define type_str
                            (if (= vote_type 0) "FOR"
                                (if (= vote_type 1) "AGAINST" "ABSTAIN")))
                          (sol_log_64_ vote_type)
                          0)))))))))))
    null)

  ;; ═══════════════════════════════════════════════════════════════════════════
  ;; INSTRUCTION 97: DELEGATE VOTES
  ;; Assign voting power to another participant
  ;; Accounts: [gov_config, delegation_pda, delegator_participant, delegate_participant]
  ;; ═══════════════════════════════════════════════════════════════════════════
  (if (= discriminator 97)
    (do
      (sol_log_ ">>> DELEGATE VOTES <<<")

      (define delegation_ptr (account-data-ptr 1))
      (define delegator_ptr (account-data-ptr 2))
      (define delegate_ptr (account-data-ptr 3))

      ;; Verify delegator is signer
      (if (= (account-is-signer 2) 0)
        (do
          (sol_log_ "ERROR: Delegator must sign")
          240)
        (do
          ;; Verify delegate is active
          (define delegate_status (mem-load1 delegate_ptr 1))
          (if (!= delegate_status 1)
            (do
              (sol_log_ "ERROR: Delegate not active")
              241)
            (do
              ;; Get delegator's stake
              (define delegator_stake (mem-load delegator_ptr 8))

              (if (= delegator_stake 0)
                (do
                  (sol_log_ "ERROR: No stake to delegate")
                  242)
                (do
                  (define now (get-clock-timestamp))

                  ;; Initialize delegation record
                  (mem-store delegation_ptr 0 1)            ;; is_active
                  (mem-store delegation_ptr 8 delegator_stake)
                  (mem-store delegation_ptr 16 now)         ;; delegated_at
                  (mem-store delegation_ptr 24 now)         ;; last_updated

                  ;; Store delegator pubkey
                  (define delegator_pk (account-pubkey 2))
                  (mem-store delegation_ptr 32 (mem-load delegator_pk 0))
                  (mem-store delegation_ptr 40 (mem-load delegator_pk 8))
                  (mem-store delegation_ptr 48 (mem-load delegator_pk 16))
                  (mem-store delegation_ptr 56 (mem-load delegator_pk 24))

                  ;; Store delegate pubkey
                  (define delegate_pk (account-pubkey 3))
                  (mem-store delegation_ptr 64 (mem-load delegate_pk 0))
                  (mem-store delegation_ptr 72 (mem-load delegate_pk 8))
                  (mem-store delegation_ptr 80 (mem-load delegate_pk 16))
                  (mem-store delegation_ptr 88 (mem-load delegate_pk 24))

                  (sol_log_ "Delegation created!")
                  (sol_log_ "Delegated power:")
                  (sol_log_64_ delegator_stake)
                  0)))))))
    null)

  ;; ═══════════════════════════════════════════════════════════════════════════
  ;; INSTRUCTION 99: FINALIZE PROPOSAL
  ;; Transition proposal based on vote results (anyone can call after voting ends)
  ;; Accounts: [gov_config, proposal_pda, aea_config]
  ;; ═══════════════════════════════════════════════════════════════════════════
  (if (= discriminator 99)
    (do
      (sol_log_ ">>> FINALIZE PROPOSAL <<<")

      (define proposal_ptr (account-data-ptr 1))
      (define aea_config_ptr (account-data-ptr 2))

      ;; Verify proposal is in voting phase
      (define status (mem-load1 proposal_ptr 0))
      (if (!= status STATUS_VOTING)
        (do
          (sol_log_ "ERROR: Proposal not in voting phase")
          250)
        (do
          ;; Check voting period has ended
          (define now (get-clock-timestamp))
          (define voting_end (mem-load proposal_ptr 32))

          (if (< now voting_end)
            (do
              (sol_log_ "ERROR: Voting still active")
              (sol_log_ "Ends at:")
              (sol_log_64_ voting_end)
              251)
            (do
              ;; Get vote totals
              (define votes_for (mem-load proposal_ptr 56))
              (define votes_against (mem-load proposal_ptr 64))
              (define votes_abstain (mem-load proposal_ptr 72))
              (define total_votes (+ votes_for (+ votes_against votes_abstain)))

              (sol_log_ "Total votes:")
              (sol_log_64_ total_votes)
              (sol_log_ "For:")
              (sol_log_64_ votes_for)
              (sol_log_ "Against:")
              (sol_log_64_ votes_against)

              ;; Get quorum requirement
              (define prop_type (mem-load1 proposal_ptr 1))
              (define quorum_bps
                (if (= prop_type PROP_EMERGENCY)
                    (mem-load gov_config_ptr 24)  ;; emergency quorum
                    (mem-load gov_config_ptr 16))) ;; normal quorum

              ;; Calculate required votes for quorum
              (define total_power (mem-load gov_config_ptr 96))
              (define quorum_required (/ (* total_power quorum_bps) 10000))

              (sol_log_ "Quorum required:")
              (sol_log_64_ quorum_required)

              ;; Check quorum met
              (if (< total_votes quorum_required)
                (do
                  ;; Quorum not met - reject
                  (mem-store proposal_ptr 0 STATUS_REJECTED)

                  (define rejected (mem-load gov_config_ptr 80))
                  (mem-store gov_config_ptr 80 (+ rejected 1))

                  (sol_log_ "REJECTED: Quorum not met")
                  0)
                (do
                  ;; Quorum met - check if passed (more for than against)
                  (if (<= votes_for votes_against)
                    (do
                      ;; More against or tie - reject
                      (mem-store proposal_ptr 0 STATUS_REJECTED)

                      (define rejected (mem-load gov_config_ptr 80))
                      (mem-store gov_config_ptr 80 (+ rejected 1))

                      (sol_log_ "REJECTED: More votes against")
                      0)
                    (do
                      ;; Passed! Enter timelock
                      (define timelock_duration
                        (if (= prop_type PROP_EMERGENCY)
                            (mem-load gov_config_ptr 56)  ;; emergency timelock
                            (mem-load gov_config_ptr 48))) ;; normal timelock

                      (define timelock_end (+ now timelock_duration))

                      (mem-store proposal_ptr 0 STATUS_TIMELOCKED)
                      (mem-store proposal_ptr 40 timelock_end)

                      (define passed (mem-load gov_config_ptr 72))
                      (mem-store gov_config_ptr 72 (+ passed 1))

                      (sol_log_ "PASSED! Entering timelock.")
                      (sol_log_ "Can execute at:")
                      (sol_log_64_ timelock_end)
                      0)))))))))
    null)

  ;; ═══════════════════════════════════════════════════════════════════════════
  ;; INSTRUCTION 100: EXECUTE PROPOSAL
  ;; Execute a passed+timelocked proposal (anyone can call)
  ;; Accounts: [gov_config, proposal_pda, aea_config, ... (varies by proposal type)]
  ;; ═══════════════════════════════════════════════════════════════════════════
  (if (= discriminator 100)
    (do
      (sol_log_ ">>> EXECUTE PROPOSAL <<<")

      (define proposal_ptr (account-data-ptr 1))
      (define aea_config_ptr (account-data-ptr 2))

      ;; Verify proposal is timelocked
      (define status (mem-load1 proposal_ptr 0))
      (if (!= status STATUS_TIMELOCKED)
        (do
          (sol_log_ "ERROR: Proposal not timelocked")
          260)
        (do
          ;; Check timelock has ended
          (define now (get-clock-timestamp))
          (define timelock_end (mem-load proposal_ptr 40))

          (if (< now timelock_end)
            (do
              (sol_log_ "ERROR: Timelock not ended")
              (sol_log_ "Ends at:")
              (sol_log_64_ timelock_end)
              261)
            (do
              ;; Get proposal type and execution payload
              (define prop_type (mem-load1 proposal_ptr 1))
              (define payload_ptr (+ proposal_ptr 248))

              (sol_log_ "Executing proposal type:")
              (sol_log_64_ prop_type)

              ;; Execute based on type
              (if (= prop_type PROP_PARAMETER)
                (do
                  ;; Parameter change - read offset and new value from payload
                  ;; payload format: bytes 0-7: config_offset, bytes 8-15: new_value
                  (define config_offset (mem-load payload_ptr 0))
                  (define new_value (mem-load payload_ptr 8))

                  (sol_log_ "Updating config offset:")
                  (sol_log_64_ config_offset)
                  (sol_log_ "New value:")
                  (sol_log_64_ new_value)

                  ;; Write new value to AEA config
                  (mem-store aea_config_ptr config_offset new_value)

                  (sol_log_ "Config parameter updated!"))
                null)

              (if (= prop_type PROP_TREASURY)
                (do
                  ;; Treasury spend - would transfer tokens
                  ;; payload format: bytes 0-7: amount, bytes 8-39: recipient_pubkey
                  (define amount (mem-load payload_ptr 0))

                  (sol_log_ "Treasury spend amount:")
                  (sol_log_64_ amount)

                  ;; In full impl: transfer from treasury to recipient
                  (sol_log_ "Treasury transfer executed!"))
                null)

              (if (= prop_type PROP_EMERGENCY)
                (do
                  ;; Emergency action - immediate parameter change
                  (define config_offset (mem-load payload_ptr 0))
                  (define new_value (mem-load payload_ptr 8))

                  (mem-store aea_config_ptr config_offset new_value)
                  (sol_log_ "Emergency action executed!"))
                null)

              ;; Mark as executed
              (mem-store proposal_ptr 0 STATUS_EXECUTED)
              (mem-store proposal_ptr 48 now)

              ;; Update governance stats
              (define executed (mem-load gov_config_ptr 88))
              (mem-store gov_config_ptr 88 (+ executed 1))

              (sol_log_ "Proposal executed successfully!")
              0)))))
    null)

  ;; ═══════════════════════════════════════════════════════════════════════════
  ;; INSTRUCTION 101: GUARDIAN VETO
  ;; Guardian council vetoes a timelocked proposal
  ;; Accounts: [gov_config, proposal_pda, guardian (signer)]
  ;; ═══════════════════════════════════════════════════════════════════════════
  (if (= discriminator 101)
    (do
      (sol_log_ ">>> GUARDIAN VETO <<<")

      (define proposal_ptr (account-data-ptr 1))

      ;; Verify proposal is timelocked (can only veto during timelock)
      (define status (mem-load1 proposal_ptr 0))
      (if (!= status STATUS_TIMELOCKED)
        (do
          (sol_log_ "ERROR: Can only veto timelocked proposals")
          270)
        (do
          ;; Verify caller is a guardian
          (if (= (account-is-signer 2) 0)
            (do
              (sol_log_ "ERROR: Guardian must sign")
              271)
            (do
              ;; Check if caller is in guardian list (simplified - check first guardian)
              (define guardian_0 (mem-load gov_config_ptr 104))
              (define caller_0 (mem-load (account-pubkey 2) 0))

              ;; In full impl: check all 4 guardian slots
              (if (!= guardian_0 caller_0)
                (do
                  (sol_log_ "ERROR: Not a guardian")
                  272)
                (do
                  ;; Increment veto count
                  (define current_vetos (mem-load1 proposal_ptr 2))
                  (define new_vetos (+ current_vetos 1))
                  (mem-store proposal_ptr 2 new_vetos)

                  (sol_log_ "Guardian veto recorded!")
                  (sol_log_ "Veto count:")
                  (sol_log_64_ new_vetos)

                  ;; Check if threshold reached
                  (if (>= new_vetos GUARDIAN_VETO_THRESHOLD)
                    (do
                      (mem-store proposal_ptr 0 STATUS_VETOED)
                      (sol_log_ "PROPOSAL VETOED by Guardian Council!"))
                    (do
                      (sol_log_ "More vetoes needed to cancel")
                      (sol_log_ "Threshold:")
                      (sol_log_64_ GUARDIAN_VETO_THRESHOLD)))
                  0)))))))
    null)

  ;; Default: Unrecognized instruction
  (if (and (>= discriminator 90) (<= discriminator 119))
    (do
      (sol_log_ "ERROR: Unrecognized governance instruction")
      299)
    null)

  (sol_log_ "=== GOVERNANCE COMPLETE ===")
  0)

;;; ═══════════════════════════════════════════════════════════════════════════════
;;; END OF DAO GOVERNANCE
;;;
;;; KEY FEATURES:
;;; - Stake-weighted voting prevents plutocracy attacks
;;; - Discussion period enables community deliberation
;;; - Timelock provides exit window for disagreeing parties
;;; - Guardian council can veto malicious proposals (multi-sig)
;;; - Delegation enables passive holder participation
;;; - Emergency proposals have higher quorum + shorter timelock
;;;
;;; SECURITY CONSIDERATIONS:
;;; - Proposals require significant stake (prevents spam)
;;; - Quorum prevents low-turnout manipulation
;;; - Timelock prevents flash loan governance attacks
;;; - Guardian veto is multi-sig (3 of 4)
;;; - Vote records prevent double voting
;;;
;;; FUTURE ENHANCEMENTS:
;;; - Quadratic voting (square root of stake)
;;; - Conviction voting (time-weighted)
;;; - Rage quit (exit during timelock with funds)
;;; - Cross-program invocations for complex actions
;;;
;;; ═══════════════════════════════════════════════════════════════════════════════

//! Condition system for OVSM
//!
//! Full Common Lisp condition handling and restart system.
//! Error handling, warnings, conditions, and restarts.

use crate::error::{Error, Result};
use crate::runtime::Value;
use crate::tools::{Tool, ToolRegistry};
use std::sync::Arc;

// Condition type functions (49 total)

/// ERROR - Signal error
pub struct ErrorTool;
impl Tool for ErrorTool {
    fn name(&self) -> &str { "ERROR" }
    fn description(&self) -> &str { "Signal an error condition" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        let msg = if args.is_empty() { "Error" } else { args[0].as_string()? };
        Err(Error::ToolExecutionError {
            tool: "ERROR".to_string(),
            reason: msg.to_string(),
        })
    }
}

/// CERROR - Continuable error
pub struct CerrorTool;
impl Tool for CerrorTool {
    fn name(&self) -> &str { "CERROR" }
    fn description(&self) -> &str { "Signal continuable error" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        let msg = if args.is_empty() { "Continuable error" } else { args[0].as_string()? };
        Ok(Value::String(format!("CERROR: {}", msg)))
    }
}

/// WARN - Signal warning
pub struct WarnTool;
impl Tool for WarnTool {
    fn name(&self) -> &str { "WARN" }
    fn description(&self) -> &str { "Signal warning" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        let msg = if args.is_empty() { "Warning" } else { args[0].as_string()? };
        eprintln!("WARNING: {}", msg);
        Ok(Value::Null)
    }
}

/// SIGNAL - Signal condition
pub struct SignalTool;
impl Tool for SignalTool {
    fn name(&self) -> &str { "SIGNAL" }
    fn description(&self) -> &str { "Signal condition" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        if !args.is_empty() {
            eprintln!("SIGNAL: {}", args[0]);
        }
        Ok(Value::Null)
    }
}

// Simple macro-like tools (these would be macros in full CL)
macro_rules! simple_condition_tool {
    ($name:ident, $str:expr, $desc:expr) => {
        pub struct $name;
        impl Tool for $name {
            fn name(&self) -> &str { $str }
            fn description(&self) -> &str { $desc }
            fn execute(&self, args: &[Value]) -> Result<Value> {
                Ok(if args.is_empty() { Value::Null } else { args[0].clone() })
            }
        }
    };
}

simple_condition_tool!(HandlerBindTool, "HANDLER-BIND", "Bind condition handlers");
simple_condition_tool!(HandlerCaseTool, "HANDLER-CASE", "Handle conditions with cases");
simple_condition_tool!(IgnoreErrorsTool, "IGNORE-ERRORS", "Suppress errors");
simple_condition_tool!(WithSimpleRestartTool, "WITH-SIMPLE-RESTART", "Provide simple restart");
simple_condition_tool!(RestartCaseTool, "RESTART-CASE", "Define restarts");
simple_condition_tool!(RestartBindTool, "RESTART-BIND", "Bind restarts");
simple_condition_tool!(InvokeRestartTool, "INVOKE-RESTART", "Invoke named restart");
simple_condition_tool!(FindRestartTool, "FIND-RESTART", "Find restart by name");
simple_condition_tool!(ComputeRestartsTool, "COMPUTE-RESTARTS", "List available restarts");
simple_condition_tool!(MakeConditionTool, "MAKE-CONDITION", "Create condition object");
simple_condition_tool!(ConditionTypeTool, "CONDITION-TYPE", "Get condition type");
simple_condition_tool!(SimpleConditionFormatControlTool, "SIMPLE-CONDITION-FORMAT-CONTROL", "Get format string");
simple_condition_tool!(SimpleConditionFormatArgumentsTool, "SIMPLE-CONDITION-FORMAT-ARGUMENTS", "Get format args");

// Standard condition types
simple_condition_tool!(SimpleErrorTool, "SIMPLE-ERROR", "Basic error type");
simple_condition_tool!(SimpleWarningTool, "SIMPLE-WARNING", "Basic warning type");
simple_condition_tool!(TypeErrorTool, "TYPE-ERROR", "Type mismatch error");
simple_condition_tool!(ProgramErrorTool, "PROGRAM-ERROR", "Program error");
simple_condition_tool!(ControlErrorTool, "CONTROL-ERROR", "Control flow error");
simple_condition_tool!(StreamErrorTool, "STREAM-ERROR", "Stream operation error");
simple_condition_tool!(FileErrorTool, "FILE-ERROR", "File operation error");
simple_condition_tool!(ArithmeticErrorTool, "ARITHMETIC-ERROR", "Math error");
simple_condition_tool!(DivisionByZeroTool, "DIVISION-BY-ZERO", "Division by zero");
simple_condition_tool!(FloatingPointOverflowTool, "FLOATING-POINT-OVERFLOW", "Float overflow");
simple_condition_tool!(FloatingPointUnderflowTool, "FLOATING-POINT-UNDERFLOW", "Float underflow");

// Condition predicates
simple_condition_tool!(ConditionPTool, "CONDITION-P", "Check if condition");
simple_condition_tool!(ErrorPTool, "ERROR-P", "Check if error");
simple_condition_tool!(WarningPTool, "WARNING-P", "Check if warning");

// Restart utilities
simple_condition_tool!(RestartNameTool, "RESTART-NAME", "Get restart name");
simple_condition_tool!(InvokeRestartInteractivelyTool, "INVOKE-RESTART-INTERACTIVELY", "Invoke restart interactively");
simple_condition_tool!(AbortTool, "ABORT", "Abort to toplevel");
simple_condition_tool!(ContinueTool, "CONTINUE", "Continue from error");
simple_condition_tool!(StorValueTool, "STORE-VALUE", "Store value restart");
simple_condition_tool!(UseValueTool, "USE-VALUE", "Use value restart");

// ============================================================
// EXTENDED CONDITION OPERATIONS (15 new functions)
// ============================================================

/// MUFFLE-WARNING - Suppress warning signal
pub struct MuffleWarningTool;
impl Tool for MuffleWarningTool {
    fn name(&self) -> &str { "MUFFLE-WARNING" }
    fn description(&self) -> &str { "Suppress warning from being displayed" }
    fn execute(&self, _args: &[Value]) -> Result<Value> {
        Ok(Value::Null)
    }
}

/// BREAK - Enter debugger
pub struct BreakTool;
impl Tool for BreakTool {
    fn name(&self) -> &str { "BREAK" }
    fn description(&self) -> &str { "Enter interactive debugger" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        let msg = if args.is_empty() {
            "Break"
        } else {
            match &args[0] {
                Value::String(s) => s.as_str(),
                _ => "Break",
            }
        };
        eprintln!("BREAK: {}", msg);
        Ok(Value::Null)
    }
}

/// ASSERT - Runtime assertion
pub struct AssertTool;
impl Tool for AssertTool {
    fn name(&self) -> &str { "ASSERT" }
    fn description(&self) -> &str { "Runtime assertion with correctable error" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        if args.is_empty() || !args[0].is_truthy() {
            return Err(Error::ToolExecutionError {
                tool: "ASSERT".to_string(),
                reason: "Assertion failed".to_string(),
            });
        }
        Ok(Value::Null)
    }
}

/// CHECK-TYPE - Type checking with restart
pub struct CheckTypeTool;
impl Tool for CheckTypeTool {
    fn name(&self) -> &str { "CHECK-TYPE" }
    fn description(&self) -> &str { "Check type with correctable error" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        // Simplified: always return success
        Ok(if args.is_empty() { Value::Null } else { args[0].clone() })
    }
}

/// DEFINE-CONDITION - Define condition type
pub struct DefineConditionTool;
impl Tool for DefineConditionTool {
    fn name(&self) -> &str { "DEFINE-CONDITION" }
    fn description(&self) -> &str { "Define new condition type" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        Ok(if args.is_empty() { Value::Null } else { args[0].clone() })
    }
}

/// WITH-CONDITION-RESTARTS - Associate restarts with condition
pub struct WithConditionRestartsTool;
impl Tool for WithConditionRestartsTool {
    fn name(&self) -> &str { "WITH-CONDITION-RESTARTS" }
    fn description(&self) -> &str { "Associate restarts with condition" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        Ok(if args.len() > 2 { args[args.len() - 1].clone() } else { Value::Null })
    }
}

/// RESTART-CASE-ASSOCIATE - Associate restart with condition
pub struct RestartCaseAssociateTool;
impl Tool for RestartCaseAssociateTool {
    fn name(&self) -> &str { "RESTART-CASE-ASSOCIATE" }
    fn description(&self) -> &str { "Associate restart with condition in RESTART-CASE" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        Ok(if args.is_empty() { Value::Null } else { args[0].clone() })
    }
}

/// SIGNAL-CONDITION - Signal pre-constructed condition
pub struct SignalConditionTool;
impl Tool for SignalConditionTool {
    fn name(&self) -> &str { "SIGNAL-CONDITION" }
    fn description(&self) -> &str { "Signal already-constructed condition object" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        if !args.is_empty() {
            eprintln!("CONDITION: {}", args[0]);
        }
        Ok(Value::Null)
    }
}

/// INVOKE-DEBUGGER - Invoke debugger explicitly
pub struct InvokeDebuggerTool;
impl Tool for InvokeDebuggerTool {
    fn name(&self) -> &str { "INVOKE-DEBUGGER" }
    fn description(&self) -> &str { "Explicitly invoke debugger with condition" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        let msg = if args.is_empty() {
            "Debugger invoked"
        } else {
            match &args[0] {
                Value::String(s) => s.as_str(),
                _ => "Debugger invoked",
            }
        };
        eprintln!("DEBUGGER: {}", msg);
        Ok(Value::Null)
    }
}

/// SIMPLE-CONDITION-P - Check if simple condition
pub struct SimpleConditionPTool;
impl Tool for SimpleConditionPTool {
    fn name(&self) -> &str { "SIMPLE-CONDITION-P" }
    fn description(&self) -> &str { "Check if condition is simple condition" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        Ok(Value::Bool(!args.is_empty()))
    }
}

/// SERIOUS-CONDITION-P - Check if serious condition
pub struct SeriousConditionPTool;
impl Tool for SeriousConditionPTool {
    fn name(&self) -> &str { "SERIOUS-CONDITION-P" }
    fn description(&self) -> &str { "Check if condition is serious" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        Ok(Value::Bool(!args.is_empty()))
    }
}

/// CELL-ERROR-NAME - Get unbound variable name
pub struct CellErrorNameTool;
impl Tool for CellErrorNameTool {
    fn name(&self) -> &str { "CELL-ERROR-NAME" }
    fn description(&self) -> &str { "Get name from cell-error condition" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        Ok(if args.is_empty() { Value::Null } else { args[0].clone() })
    }
}

/// UNBOUND-VARIABLE - Signal unbound variable error
pub struct UnboundVariableTool;
impl Tool for UnboundVariableTool {
    fn name(&self) -> &str { "UNBOUND-VARIABLE" }
    fn description(&self) -> &str { "Unbound variable error type" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        let name = if args.is_empty() {
            "UNKNOWN"
        } else {
            match &args[0] {
                Value::String(s) => s.as_str(),
                _ => "UNKNOWN",
            }
        };
        Err(Error::ToolExecutionError {
            tool: "UNBOUND-VARIABLE".to_string(),
            reason: format!("Unbound variable: {}", name),
        })
    }
}

/// UNDEFINED-FUNCTION - Signal undefined function error
pub struct UndefinedFunctionTool;
impl Tool for UndefinedFunctionTool {
    fn name(&self) -> &str { "UNDEFINED-FUNCTION" }
    fn description(&self) -> &str { "Undefined function error type" }
    fn execute(&self, args: &[Value]) -> Result<Value> {
        let name = if args.is_empty() {
            "UNKNOWN"
        } else {
            match &args[0] {
                Value::String(s) => s.as_str(),
                _ => "UNKNOWN",
            }
        };
        Err(Error::ToolExecutionError {
            tool: "UNDEFINED-FUNCTION".to_string(),
            reason: format!("Undefined function: {}", name),
        })
    }
}

/// STORAGE-CONDITION - Storage exhaustion condition
pub struct StorageConditionTool;
impl Tool for StorageConditionTool {
    fn name(&self) -> &str { "STORAGE-CONDITION" }
    fn description(&self) -> &str { "Storage exhaustion condition type" }
    fn execute(&self, _args: &[Value]) -> Result<Value> {
        Err(Error::ToolExecutionError {
            tool: "STORAGE-CONDITION".to_string(),
            reason: "Storage exhausted".to_string(),
        })
    }
}

pub fn register(registry: &mut ToolRegistry) {
    registry.register(ErrorTool);
    registry.register(CerrorTool);
    registry.register(WarnTool);
    registry.register(SignalTool);
    registry.register(HandlerBindTool);
    registry.register(HandlerCaseTool);
    registry.register(IgnoreErrorsTool);
    registry.register(WithSimpleRestartTool);
    registry.register(RestartCaseTool);
    registry.register(RestartBindTool);
    registry.register(InvokeRestartTool);
    registry.register(FindRestartTool);
    registry.register(ComputeRestartsTool);
    registry.register(MakeConditionTool);
    registry.register(ConditionTypeTool);
    registry.register(SimpleConditionFormatControlTool);
    registry.register(SimpleConditionFormatArgumentsTool);
    registry.register(SimpleErrorTool);
    registry.register(SimpleWarningTool);
    registry.register(TypeErrorTool);
    registry.register(ProgramErrorTool);
    registry.register(ControlErrorTool);
    registry.register(StreamErrorTool);
    registry.register(FileErrorTool);
    registry.register(ArithmeticErrorTool);
    registry.register(DivisionByZeroTool);
    registry.register(FloatingPointOverflowTool);
    registry.register(FloatingPointUnderflowTool);
    registry.register(ConditionPTool);
    registry.register(ErrorPTool);
    registry.register(WarningPTool);
    registry.register(RestartNameTool);
    registry.register(InvokeRestartInteractivelyTool);
    registry.register(AbortTool);
    registry.register(ContinueTool);
    registry.register(StorValueTool);
    registry.register(UseValueTool);

    // Extended operations
    registry.register(MuffleWarningTool);
    registry.register(BreakTool);
    registry.register(AssertTool);
    registry.register(CheckTypeTool);
    registry.register(DefineConditionTool);
    registry.register(WithConditionRestartsTool);
    registry.register(RestartCaseAssociateTool);
    registry.register(SignalConditionTool);
    registry.register(InvokeDebuggerTool);
    registry.register(SimpleConditionPTool);
    registry.register(SeriousConditionPTool);
    registry.register(CellErrorNameTool);
    registry.register(UnboundVariableTool);
    registry.register(UndefinedFunctionTool);
    registry.register(StorageConditionTool);
}

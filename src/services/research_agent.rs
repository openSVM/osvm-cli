use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use crate::services::ai_service::AiService;
use crate::services::ovsm_service::OvsmService;
use std::sync::Arc;
use tokio::sync::Mutex;
use ovsm::runtime::Value;

/// Represents the state of our investigation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InvestigationState {
    pub target_wallet: String,
    pub phase: InvestigationPhase,
    pub findings: Vec<Finding>,
    pub hypotheses: Vec<Hypothesis>,
    pub evidence: HashMap<String, Evidence>,
    pub next_steps: Vec<String>,
    pub confidence_scores: HashMap<String, f64>,
    pub iteration: u32,
    /// High-level TODO list dynamically generated by AI
    pub investigation_todos: Vec<InvestigationTodo>,
    /// Current thinking/reasoning about what to do next
    pub current_reasoning: String,
    /// Knowledge graph of wallet relationships
    pub knowledge_graph: WalletKnowledgeGraph,
}

/// Knowledge graph representing wallet relationships and flows
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WalletKnowledgeGraph {
    #[serde(rename = "@context")]
    pub context: String,
    #[serde(rename = "@type")]
    pub graph_type: String,
    pub wallets: HashMap<String, WalletNode>,
    pub relationships: Vec<WalletRelationship>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WalletNode {
    #[serde(rename = "@id")]
    pub id: String,
    #[serde(rename = "@type")]
    pub node_type: String,
    pub label: String,
    pub first_seen: Option<String>,
    pub total_volume: f64,
    pub wallet_type: String, // "target", "funding_source", "receiver", "related"
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WalletRelationship {
    #[serde(rename = "@type")]
    pub rel_type: String,
    pub from: String,
    pub to: String,
    pub relationship_type: RelationshipType,
    pub volume: f64,
    pub tx_count: u32,
    pub confidence: f64, // 0.0-1.0 indicating likelihood of same owner
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RelationshipType {
    Funding,        // Initial wallet funding
    RoundTrip,      // Bidirectional transfers (high confidence same owner)
    SimpleTransfer, // Pure SOL/SPL without DeFi
    DeFiInteraction,
    Coordinated,    // Same-block or sequential activity
}

/// Path-based visualization structures
#[derive(Debug, Clone)]
pub struct WalletPath {
    pub hops: Vec<PathHop>,
    pub total_volume: f64,
    pub confidence: f64,
    pub most_recent_timestamp: Option<String>,
    pub path_type: PathType,
}

#[derive(Debug, Clone)]
pub struct PathHop {
    pub wallet: String,
    pub amount: f64,
    pub timestamp: Option<String>,
    pub depth: usize,
}

#[derive(Debug, Clone, PartialEq)]
pub enum PathType {
    Inflow,   // Funding source â†’ Target
    Outflow,  // Target â†’ Receiver
    RoundTrip, // Bidirectional
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TransferGraph Module - Clean ASCII Visualization
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Represents a single transfer in the graph
#[derive(Debug, Clone)]
pub struct Transfer {
    pub from: String,
    pub to: String,
    pub amount: f64,
    pub token_symbol: String,
    pub timestamp: Option<String>,
    pub note: Option<String>,
}

/// Represents a node in the transfer graph
#[derive(Debug, Clone)]
pub struct GraphNode {
    pub address: String,
    pub label: Option<String>,
    pub incoming: Vec<Transfer>,
    pub outgoing: Vec<Transfer>,
}

/// Configuration for rendering ASCII output
#[derive(Debug, Clone)]
pub struct RenderConfig {
    pub title: String,
    pub origin_icon: String,
    pub target_icon: String,
    pub node_icon: String,
    pub show_header: bool,
    pub show_paths_summary: bool,
    pub show_stats_summary: bool,
    pub address_truncate_length: usize,
}

impl Default for RenderConfig {
    fn default() -> Self {
        RenderConfig {
            title: "TOKEN DISTRIBUTION TRACE".to_string(),
            origin_icon: "ğŸ¦ ORIGIN".to_string(),
            target_icon: "ğŸ¯ TARGET".to_string(),
            node_icon: "â—‹".to_string(),
            show_header: true,
            show_paths_summary: true,
            show_stats_summary: true,
            address_truncate_length: 12,
        }
    }
}

/// Represents the complete transfer graph
pub struct TransferGraph {
    pub nodes: HashMap<String, GraphNode>,
    pub origin: Option<String>,
    pub target: Option<String>,
    pub token_name: Option<String>,
    pub token_mint: Option<String>,
    pub render_config: RenderConfig,
}

impl TransferGraph {
    pub fn new() -> Self {
        TransferGraph {
            nodes: HashMap::new(),
            origin: None,
            target: None,
            token_name: None,
            token_mint: None,
            render_config: RenderConfig::default(),
        }
    }

    pub fn with_config(config: RenderConfig) -> Self {
        TransferGraph {
            nodes: HashMap::new(),
            origin: None,
            target: None,
            token_name: None,
            token_mint: None,
            render_config: config,
        }
    }

    /// Add a transfer to the graph
    pub fn add_transfer(&mut self, transfer: Transfer) {
        // Add to sender's outgoing
        self.nodes
            .entry(transfer.from.clone())
            .or_insert_with(|| GraphNode {
                address: transfer.from.clone(),
                label: None,
                incoming: Vec::new(),
                outgoing: Vec::new(),
            })
            .outgoing
            .push(transfer.clone());

        // Add to receiver's incoming
        self.nodes
            .entry(transfer.to.clone())
            .or_insert_with(|| GraphNode {
                address: transfer.to.clone(),
                label: None,
                incoming: Vec::new(),
                outgoing: Vec::new(),
            })
            .incoming
            .push(transfer);
    }

    /// Set a label for a node
    pub fn set_node_label(&mut self, address: &str, label: String) {
        if let Some(node) = self.nodes.get_mut(address) {
            node.label = Some(label);
        }
    }

    /// Find all paths from origin to target
    pub fn find_paths(&self, from: &str, to: &str) -> Vec<Vec<String>> {
        let mut paths = Vec::new();
        let mut current_path = Vec::new();
        let mut visited = HashSet::new();

        self.dfs_paths(from, to, &mut current_path, &mut visited, &mut paths);
        paths
    }

    fn dfs_paths(
        &self,
        current: &str,
        target: &str,
        path: &mut Vec<String>,
        visited: &mut HashSet<String>,
        all_paths: &mut Vec<Vec<String>>,
    ) {
        path.push(current.to_string());
        visited.insert(current.to_string());

        if current == target {
            all_paths.push(path.clone());
        } else if let Some(node) = self.nodes.get(current) {
            for transfer in &node.outgoing {
                if !visited.contains(&transfer.to) {
                    self.dfs_paths(&transfer.to, target, path, visited, all_paths);
                }
            }
        }

        visited.remove(current);
        path.pop();
    }

    /// Render the graph as ASCII art using the configured settings
    pub fn render_ascii(&self) -> String {
        let mut output = String::new();
        let cfg = &self.render_config;

        // Header with configurable title
        if cfg.show_header {
            let title_padded = self.center_text(&cfg.title, 74);
            output.push_str("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
            output.push_str(&format!("â•‘{}â•‘\n", title_padded));
            output.push_str("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
        }

        if let Some(token) = &self.token_name {
            output.push_str(&format!("TOKEN: {}", token));
            if let Some(mint) = &self.token_mint {
                output.push_str(&format!(" ({})", self.truncate_address(mint, 8)));
            }
            output.push_str("\n");
        }

        if let Some(target) = &self.target {
            output.push_str(&format!("TARGET: {}\n\n", target));
        }

        output.push_str("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

        // Render the graph tree starting from origin
        if let Some(origin_addr) = &self.origin {
            self.render_node(&mut output, origin_addr, 0, &mut HashSet::new(), true);
        }

        // Render paths summary if configured and we have origin and target
        if cfg.show_paths_summary {
            if let (Some(origin), Some(target)) = (&self.origin, &self.target) {
                let paths = self.find_paths(origin, target);
                output.push_str("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n");
                output.push_str(&format!("PATHS SUMMARY ({} paths found):\n\n", paths.len()));

                for (idx, path) in paths.iter().enumerate() {
                    output.push_str(&format!("PATH #{}: ", idx + 1));
                    for (i, addr) in path.iter().enumerate() {
                        if i > 0 {
                            output.push_str(" â†’ ");
                        }
                        output.push_str(&self.truncate_address(addr, 8));
                    }
                    output.push_str("\n");
                }
            }
        }

        // Summary section if configured
        if cfg.show_stats_summary {
            output.push_str("\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
            output.push_str(&format!("â”‚ Total Nodes: {:>58} â”‚\n", self.nodes.len()));

            let total_transfers: usize = self.nodes.values()
                .map(|n| n.outgoing.len())
                .sum();
            output.push_str(&format!("â”‚ Total Transfers: {:>54} â”‚\n", total_transfers));

            if let Some(target_addr) = &self.target {
                if let Some(target_node) = self.nodes.get(target_addr) {
                    let total_received: f64 = target_node.incoming.iter()
                        .map(|t| t.amount)
                        .sum();
                    output.push_str(&format!("â”‚ Target Received: {:>54.2} â”‚\n", total_received));
                }
            }
            output.push_str("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
        }

        output
    }

    fn center_text(&self, text: &str, width: usize) -> String {
        let text_len = text.len();
        if text_len >= width {
            return text.to_string();
        }
        let padding = (width - text_len) / 2;
        let extra = (width - text_len) % 2;
        format!("{}{}{}", " ".repeat(padding), text, " ".repeat(padding + extra))
    }

    fn render_node(
        &self,
        output: &mut String,
        addr: &str,
        depth: usize,
        visited: &mut HashSet<String>,
        is_origin: bool,
    ) {
        if visited.contains(addr) {
            return;
        }
        visited.insert(addr.to_string());

        let indent = "      ".repeat(depth);  // 6 spaces per level
        let node = self.nodes.get(addr);
        let cfg = &self.render_config;

        // Node header with configurable icons
        if is_origin {
            output.push_str(&cfg.origin_icon);
        } else if Some(addr) == self.target.as_deref() {
            output.push_str(&format!("{}{}", indent, cfg.target_icon));
        } else {
            output.push_str(&format!("{}{}", indent, cfg.node_icon));
        }

        // Node label or address
        if let Some(node) = node {
            if let Some(label) = &node.label {
                output.push_str(&format!(" {}", label));
            }
        }
        output.push_str(&format!(" {}\n", self.truncate_address(addr, cfg.address_truncate_length)));

        // Render outgoing transfers
        if let Some(node) = node {
            let outgoing_count = node.outgoing.len();
            for (idx, transfer) in node.outgoing.iter().enumerate() {
                let is_last = idx == outgoing_count - 1;
                let pipe = if is_last { " " } else { "â”‚" };
                let connector = if is_last { "â””" } else { "â”œ" };

                // Add vertical guide line before transfer
                if outgoing_count > 1 {
                    output.push_str(&format!("{}      {}\n", indent, pipe));
                }

                // Transfer line with amount and metadata
                output.push_str(&format!(
                    "{}      {}â”€â”€â”€â”€â”€â”€â†’ [{} {}]",
                    indent,
                    connector,
                    self.format_amount(transfer.amount),
                    transfer.token_symbol
                ));

                if let Some(ts) = &transfer.timestamp {
                    output.push_str(&format!(" ({})", ts));
                }

                if let Some(note) = &transfer.note {
                    output.push_str(&format!(" [{}]", note));
                }

                output.push_str("\n");

                // Arrow pointing to destination with guide line
                output.push_str(&format!(
                    "{}      {}         â†“\n",
                    indent,
                    pipe
                ));
                output.push_str(&format!(
                    "{}      {}      {} {}\n",
                    indent,
                    pipe,
                    "TO:",
                    self.truncate_address(&transfer.to, cfg.address_truncate_length)
                ));

                // Add spacing line before child node
                if !visited.contains(&transfer.to) {
                    output.push_str(&format!("{}      {}\n", indent, pipe));
                }

                // Recursively render child nodes
                if !visited.contains(&transfer.to) {
                    self.render_node(output, &transfer.to, depth + 1, visited, false);

                    // Add blank lines after each child node for better visual separation
                    if !is_last {
                        output.push_str("\n");
                    }
                }
            }
        }
    }

    fn truncate_address(&self, addr: &str, keep: usize) -> String {
        if addr.len() <= keep * 2 {
            addr.to_string()
        } else {
            format!("{}...{}", &addr[..keep], &addr[addr.len()-keep..])
        }
    }

    fn format_amount(&self, amount: f64) -> String {
        let formatted = format!("{:.2}", amount);
        let parts: Vec<&str> = formatted.split('.').collect();
        let integer_part = parts[0];
        let decimal_part = if parts.len() > 1 { parts[1] } else { "00" };

        // Add thousand separators
        let mut result = String::new();
        let chars: Vec<char> = integer_part.chars().collect();
        for (i, c) in chars.iter().enumerate() {
            if i > 0 && (chars.len() - i) % 3 == 0 {
                result.push(',');
            }
            result.push(*c);
        }

        format!("{}.{}", result, decimal_part)
    }
}

impl Default for TransferGraph {
    fn default() -> Self {
        Self::new()
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// End TransferGraph Module
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Represents a high-level investigation task
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InvestigationTodo {
    pub task: String,
    pub status: TodoStatus,
    pub priority: u8, // 1-5, with 5 being highest
    pub reason: String,
    pub findings_so_far: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TodoStatus {
    Pending,
    InProgress,
    Completed,
    Blocked,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum InvestigationPhase {
    Initial,
    BasicProfiling,
    DeepAnalysis,
    PatternRecognition,
    HypothesisTesting,
    Synthesis,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Finding {
    pub category: String,
    pub description: String,
    pub significance: f64,
    pub raw_data: serde_json::Value,
    pub timestamp: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Hypothesis {
    pub statement: String,
    pub confidence: f64,
    pub supporting_evidence: Vec<String>,
    pub contradicting_evidence: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Evidence {
    pub data_type: String,
    pub value: serde_json::Value,
    pub source: String,
    pub reliability: f64,
}

#[derive(Clone)]
pub struct ResearchAgent {
    ai_service: Arc<Mutex<AiService>>,
    ovsm_service: Arc<Mutex<OvsmService>>,
    state: Arc<Mutex<InvestigationState>>,
}

impl ResearchAgent {
    pub fn new(
        ai_service: Arc<Mutex<AiService>>,
        ovsm_service: Arc<Mutex<OvsmService>>,
        target_wallet: String,
    ) -> Self {
        let initial_state = InvestigationState {
            target_wallet: target_wallet.clone(),
            phase: InvestigationPhase::Initial,
            findings: Vec::new(),
            hypotheses: Vec::new(),
            evidence: HashMap::new(),
            next_steps: vec![
                "Get basic wallet info".to_string(),
                "Analyze recent transactions".to_string(),
                "Identify interaction patterns".to_string(),
            ],
            confidence_scores: HashMap::new(),
            iteration: 0,
            investigation_todos: Vec::new(),
            current_reasoning: String::new(),
            knowledge_graph: WalletKnowledgeGraph {
                context: "https://schema.org/".to_string(),
                graph_type: "WalletRelationshipGraph".to_string(),
                wallets: {
                    let mut map = HashMap::new();
                    map.insert(target_wallet.clone(), WalletNode {
                        id: format!("wallet:{}", target_wallet),
                        node_type: "SolanaWallet".to_string(),
                        label: format!("{}...{}", &target_wallet[..6], &target_wallet[target_wallet.len()-4..]),
                        first_seen: None,
                        total_volume: 0.0,
                        wallet_type: "target".to_string(),
                    });
                    map
                },
                relationships: Vec::new(),
            },
        };

        Self {
            ai_service,
            ovsm_service,
            state: Arc::new(Mutex::new(initial_state)),
        }
    }

    /// Generate initial investigation plan (TODO list) using AI
    async fn generate_investigation_plan(&self) -> Result<Vec<InvestigationTodo>> {
        let state = self.state.lock().await.clone();

        let planning_prompt = format!(r#"You are an expert blockchain investigator. Create a high-level investigation plan for wallet:
{}

Available MCP tools:
- get_account_transfers (transfer history)
- get_account_transactions (detailed tx data with program interactions)
- get_account_stats (activity metrics, first/last seen)
- get_account_portfolio (current holdings and values)
- get_defi_overview (DeFi protocol interactions)
- analyze_transaction (AI-powered transaction analysis)
- get_dex_analytics (trading patterns)
- chart (OHLCV price data)
- get_token_info (token metadata)

**CRITICAL: Include wallet relationship analysis to identify:**
1. **Funding relationships** - Who funded this wallet's first transaction? (same owner indicator)
2. **Round-trip transfers** - Wallets sending to each other (likely same owner)
3. **Simple transfers** - Pure SOL/SPL transfers without DeFi (personal wallet behavior)
4. **Wallet clusters** - Multiple wallets with coordinated activity

Generate 5-8 investigation tasks, prioritized 1-5 (5=highest).
**Include at least one task focused on identifying related/controlled wallets.**
Return as JSON array:
[{{"task": "...", "priority": 5, "reason": "..."}}, ...]"#, state.target_wallet);

        let ai_service = self.ai_service.lock().await;
        let plan_json = ai_service.query_with_system_prompt(
            "You are a blockchain investigation planner. Return ONLY valid JSON array, no markdown.",
            &planning_prompt
        ).await?;

        // Parse AI response into TODO list
        let plan_json_clean = plan_json.trim()
            .trim_start_matches("```json")
            .trim_start_matches("```")
            .trim_end_matches("```")
            .trim();

        let todos: Result<Vec<serde_json::Value>, _> = serde_json::from_str(plan_json_clean);

        match todos {
            Ok(todo_vals) => {
                let mut investigation_todos = Vec::new();
                for val in todo_vals {
                    investigation_todos.push(InvestigationTodo {
                        task: val["task"].as_str().unwrap_or("Unknown task").to_string(),
                        status: TodoStatus::Pending,
                        priority: val["priority"].as_u64().unwrap_or(3) as u8,
                        reason: val["reason"].as_str().unwrap_or("").to_string(),
                        findings_so_far: Vec::new(),
                    });
                }
                Ok(investigation_todos)
            }
            Err(_) => {
                // Fallback to default plan
                Ok(vec![
                    InvestigationTodo {
                        task: "Analyze transfer patterns and counterparties".to_string(),
                        status: TodoStatus::Pending,
                        priority: 5,
                        reason: "Understand wallet's primary activity".to_string(),
                        findings_so_far: Vec::new(),
                    },
                    InvestigationTodo {
                        task: "Investigate DeFi protocol interactions".to_string(),
                        status: TodoStatus::Pending,
                        priority: 4,
                        reason: "Identify trading strategies".to_string(),
                        findings_so_far: Vec::new(),
                    },
                ])
            }
        }
    }

    /// Stream a thinking message to show agent's reasoning
    fn stream_thinking(&self, message: &str) {
        println!("ğŸ§  {}", message);
    }

    /// Update investigation TODO list based on current findings
    async fn update_investigation_todos(&self, new_findings: &str) -> Result<()> {
        let mut state = self.state.lock().await;

        // Find first pending/in-progress TODO and update it
        for todo in state.investigation_todos.iter_mut() {
            if todo.status == TodoStatus::InProgress {
                todo.findings_so_far.push(new_findings.to_string());
                // Check if we should mark as completed
                if new_findings.contains("completed") || new_findings.contains("done") {
                    todo.status = TodoStatus::Completed;
                    self.stream_thinking(&format!("âœ… Completed: {}", todo.task));
                }
                break;
            }
        }

        // Move to next pending TODO
        for todo in state.investigation_todos.iter_mut() {
            if todo.status == TodoStatus::Pending {
                todo.status = TodoStatus::InProgress;
                self.stream_thinking(&format!("â–¶ï¸  Starting: {} (Priority: {})", todo.task, todo.priority));
                break;
            }
        }

        Ok(())
    }

    /// Decide what to investigate next based on current findings
    async fn decide_next_action(&self) -> Result<String> {
        let state = self.state.lock().await.clone();

        let decision_prompt = format!(r#"You are a blockchain investigator. Based on current findings, decide the NEXT specific action to take.

Current State:
- Wallet: {}
- Iteration: {}
- Findings so far: {}
- Current TODOs: {:?}

What is the single most valuable action to take next? Choose from:
1. Analyze specific transactions with analyze_transaction
2. Get DeFi overview with get_defi_overview
3. Check current portfolio with get_account_portfolio
4. Analyze trading patterns with get_dex_analytics
5. **Investigate wallet relationships** - identify funding sources, round-trip transfers, wallet clusters
6. Deep-dive into a specific finding

**IMPORTANT: If you notice simple SOL/SPL transfers or funding patterns, prioritize wallet relationship analysis!**

Return JSON: {{"action": "...", "reason": "...", "mcp_tool": "...", "parameters": {{...}}}}
"#, state.target_wallet, state.iteration, state.findings.len(), state.investigation_todos);

        let ai_service = self.ai_service.lock().await;
        let decision = ai_service.query_with_system_prompt(
            "You are a strategic investigator. Return ONLY valid JSON object.",
            &decision_prompt
        ).await?;

        Ok(decision)
    }

    /// Main investigation loop with TRUE AGENTIC self-direction
    pub async fn investigate(&self) -> Result<String> {
        println!("\nğŸ”¬ Initiating Agentic Wallet Investigation...\n");

        // Step 1: Generate initial investigation plan (TODO list)
        self.stream_thinking("Creating investigation strategy...");
        let investigation_plan = self.generate_investigation_plan().await?;

        {
            let mut state = self.state.lock().await;
            state.investigation_todos = investigation_plan.clone();
        }

        println!("\nğŸ“‹ Investigation Plan:");
        for (i, todo) in investigation_plan.iter().enumerate() {
            println!("   {}. [Priority {}] {} - {}",
                     i + 1, todo.priority, todo.task, todo.reason);
        }
        println!();

        let max_iterations = 15;

        for iteration in 0..max_iterations {
            println!("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
            println!("? Iteration #{}", iteration + 1);
            println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n");

            // 1. Decide next action based on current state
            self.stream_thinking("Analyzing current findings and deciding next action...");
            let decision = self.decide_next_action().await?;

            self.stream_thinking(&format!("Decision: {}", decision.lines().next().unwrap_or("Investigating...")));

            // 2. Execute the chosen action via OVSM + MCP
            self.stream_thinking("Executing investigation step via OVSM...");
            let result = self.execute_dynamic_investigation(&decision).await?;

            // 2.5. Build knowledge graph if we got transfer data
            {
                let state = self.state.lock().await;
                let should_build = state.findings.last()
                    .map(|f| f.category.contains("get_account_transfers"))
                    .unwrap_or(false);
                let raw_data = state.findings.last().map(|f| f.raw_data.clone());
                drop(state);

                if should_build {
                    if let Some(data) = raw_data {
                        self.build_knowledge_graph_from_transfers(&data).await?;
                        self.stream_thinking("Updated knowledge graph with new relationships");

                        // Display ASCII map immediately (no AI needed!)
                        let state = self.state.lock().await;
                        let ascii_graph = self.render_ascii_graph(&state);
                        println!("{}", ascii_graph);
                    }
                }
            }

            // 3. Stream findings in real-time
            println!("\nğŸ“Š Findings:");
            println!("{}", result);

            // 4. Self-evaluate: What did we learn? What's next?
            self.stream_thinking("Self-evaluating findings...");
            let evaluation = match tokio::time::timeout(
                tokio::time::Duration::from_secs(30),
                self.evaluate_and_reflect(&result)
            ).await {
                Ok(Ok(eval)) => {
                    println!("\nğŸ§  AI Reflection:");
                    println!("{}", eval);
                    eval
                }
                Ok(Err(e)) => {
                    println!("\nâš ï¸  Reflection skipped: {}", e);
                    "Continuing investigation...".to_string()
                }
                Err(_) => {
                    println!("\nâš ï¸  Reflection timeout - continuing investigation");
                    "Timeout - continuing...".to_string()
                }
            };

            // 5. Update TODO list based on findings
            self.update_investigation_todos(&result).await?;

            // 6. Check if investigation is complete
            let state = self.state.lock().await.clone();
            let all_completed = state.investigation_todos.iter()
                .all(|t| t.status == TodoStatus::Completed || t.status == TodoStatus::Blocked);

            {
                let mut state = self.state.lock().await;
                state.iteration = iteration + 1;
            }

            if all_completed && iteration >= 5 {
                self.stream_thinking("All investigation tasks completed!");
                println!("\nâœ… Investigation complete after {} iterations", iteration + 1);
                break;
            }

            // Small delay to make streaming visible
            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
        }

        // Display ASCII wallet relationship map
        {
            let state = self.state.lock().await;
            let ascii_graph = self.render_ascii_graph(&state);
            println!("{}", ascii_graph);
        }

        // Save knowledge graph to JSON-LD
        self.save_knowledge_graph().await?;

        // Generate final comprehensive report
        self.stream_thinking("Synthesizing final report...");
        let final_report = self.generate_final_report().await?;
        Ok(final_report)
    }

    /// Execute a dynamically chosen investigation action based on AI decision
    async fn execute_dynamic_investigation(&self, decision_json: &str) -> Result<String> {
        // Parse the AI's decision about what to investigate
        let decision_clean = decision_json.trim()
            .trim_start_matches("```json")
            .trim_start_matches("```")
            .trim_end_matches("```")
            .trim();

        let decision: Result<serde_json::Value, _> = serde_json::from_str(decision_clean);

        let (mcp_tool, params) = match decision {
            Ok(dec) => {
                let tool = dec["mcp_tool"].as_str().unwrap_or("get_account_transfers").to_string();
                let params = dec["parameters"].clone();
                (tool, params)
            }
            Err(_) => {
                // Fallback: use account transfers
                ("get_account_transfers".to_string(), serde_json::json!({}))
            }
        };

        // Generate OVSM script to call the chosen MCP tool
        let state = self.state.lock().await.clone();
        let ovsm_script = format!(r#"(do
  (define wallet "{}")

  ;; Execute dynamically chosen MCP tool: {}
  (define result ({} {{:address wallet}}))

  ;; Return structured findings
  {{:tool "{}"
   :wallet wallet
   :data result}}
)"#, state.target_wallet, mcp_tool, mcp_tool, mcp_tool);

        self.stream_thinking(&format!("Calling MCP tool: {}", mcp_tool));

        // Execute OVSM script
        let mut ovsm = self.ovsm_service.lock().await;
        let result_value = ovsm.execute_code(&ovsm_script)
            .context("Failed to execute dynamic investigation")?;

        // Convert to JSON for analysis
        let result_json = self.value_to_json(result_value)?;

        // Format findings
        let findings = format!("Tool: {}\nData: {}",
                               mcp_tool,
                               serde_json::to_string_pretty(&result_json)?);

        // Store as finding
        {
            let mut state = self.state.lock().await;
            state.findings.push(Finding {
                category: format!("Dynamic: {}", mcp_tool),
                description: format!("Executed {} on wallet", mcp_tool),
                significance: 0.7,
                raw_data: result_json,
                timestamp: std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap()
                    .as_secs(),
            });
        }

        Ok(findings)
    }

    /// Self-evaluate findings and reflect on what was learned
    async fn evaluate_and_reflect(&self, findings: &str) -> Result<String> {
        let state = self.state.lock().await.clone();

        let reflection_prompt = format!(r#"You are a blockchain investigator reflecting on new findings.

Current Investigation State:
- Wallet: {}
- Iteration: {}
- Total findings so far: {}
- Current TODOs: {} pending, {} in progress, {} completed

New Findings:
{}

Reflect on:
1. What did we learn from this data?
2. Does it confirm or contradict any existing hypotheses?
3. **WALLET RELATIONSHIPS**: Do we see patterns suggesting related wallets?
   - Simple SOL/SPL transfers without DeFi (personal use)?
   - Funding relationships (who funded this wallet initially)?
   - Round-trip transfers (A â†’ B, then B â†’ A)?
   - Coordinated activity with specific addresses?
4. What new questions does it raise?
5. What should we investigate next to maximize insight?

**CRITICAL: If you see funding or simple transfer patterns, explicitly state "Need to investigate wallet X as potential related wallet"**

Be specific and actionable. Focus on INTELLIGENCE and RELATIONSHIPS, not just data description."#,
            state.target_wallet,
            state.iteration,
            state.findings.len(),
            state.investigation_todos.iter().filter(|t| t.status == TodoStatus::Pending).count(),
            state.investigation_todos.iter().filter(|t| t.status == TodoStatus::InProgress).count(),
            state.investigation_todos.iter().filter(|t| t.status == TodoStatus::Completed).count(),
            findings
        );

        let ai_service = self.ai_service.lock().await;
        let reflection = ai_service.query_with_system_prompt(
            "You are a strategic blockchain investigator who thinks deeply about patterns and intelligence.",
            &reflection_prompt
        ).await?;

        // Update current reasoning in state
        {
            let mut state = self.state.lock().await;
            state.current_reasoning = reflection.clone();
        }

        Ok(reflection)
    }

    /// Build deep knowledge graph with recursive wallet traversal (depth-5)
    async fn build_knowledge_graph_from_transfers(&self, transfers_json: &serde_json::Value) -> Result<()> {
        // Start with target wallet transfers
        self.process_wallet_transfers(&transfers_json, 0).await?;

        // Recursively expand the graph to depth 5
        self.expand_graph_recursively(5).await?;

        Ok(())
    }

    /// Process transfers for a single wallet and add to graph
    async fn process_wallet_transfers(&self, transfers_json: &serde_json::Value, current_depth: usize) -> Result<()> {
        let mut state = self.state.lock().await;
        let target = state.target_wallet.clone();

        if let Some(transfers) = transfers_json["data"]["data"].as_array() {
            for transfer in transfers {
                let tx_type = transfer["txType"].as_str().unwrap_or("");

                // ONLY process sol/spl transfers (skip DeFi!)
                if tx_type != "sol" && tx_type != "spl" {
                    continue;
                }

                let from = transfer["from"].as_str().unwrap_or("");
                let to = transfer["to"].as_str().unwrap_or("");
                let amount = transfer["tokenAmount"].as_str()
                    .and_then(|s| s.parse::<f64>().ok())
                    .unwrap_or(0.0);
                let transfer_type = transfer["transferType"].as_str().unwrap_or("");

                // Skip if either wallet is empty
                if from.is_empty() || to.is_empty() {
                    continue;
                }

                // Add wallets to graph with depth tracking
                for wallet in [from, to] {
                    if !state.knowledge_graph.wallets.contains_key(wallet) {
                        let wallet_type = if wallet == target {
                            "target"
                        } else if transfer_type == "IN" && wallet == from {
                            "funding_source"
                        } else if transfer_type == "OUT" && wallet == to {
                            "receiver"
                        } else {
                            "related"
                        };

                        state.knowledge_graph.wallets.insert(wallet.to_string(), WalletNode {
                            id: format!("wallet:{}", wallet),
                            node_type: "SolanaWallet".to_string(),
                            label: format!("{}...{}", &wallet[..6], &wallet[wallet.len()-4..]),
                            first_seen: transfer["date"].as_str().map(String::from),
                            total_volume: amount,
                            wallet_type: wallet_type.to_string(),
                        });
                    } else {
                        // Update volume for existing wallet
                        if let Some(node) = state.knowledge_graph.wallets.get_mut(wallet) {
                            node.total_volume += amount;
                        }
                    }
                }

                // Check if reverse relationship exists (round-trip indicator)
                let has_reverse = state.knowledge_graph.relationships.iter()
                    .any(|r| r.from == to && r.to == from && r.relationship_type == RelationshipType::SimpleTransfer);

                let rel_type = if has_reverse {
                    RelationshipType::RoundTrip
                } else {
                    RelationshipType::SimpleTransfer
                };

                let confidence = if has_reverse { 0.95 } else { 0.7 };

                // Add or update relationship
                if let Some(existing) = state.knowledge_graph.relationships.iter_mut()
                    .find(|r| r.from == from && r.to == to) {
                    existing.volume += amount;
                    existing.tx_count += 1;
                    existing.relationship_type = rel_type.clone();
                    existing.confidence = confidence;
                } else {
                    state.knowledge_graph.relationships.push(WalletRelationship {
                        rel_type: "Transfer".to_string(),
                        from: from.to_string(),
                        to: to.to_string(),
                        relationship_type: rel_type,
                        volume: amount,
                        tx_count: 1,
                        confidence,
                    });
                }
            }
        }

        Ok(())
    }

    /// Recursively expand the graph by spawning independent tasks for each wallet
    async fn expand_graph_recursively(&self, max_depth: usize) -> Result<()> {
        use std::sync::Arc;
        use tokio::sync::Mutex as TokioMutex;

        let visited = Arc::new(TokioMutex::new(std::collections::HashSet::new()));
        let target_wallet = {
            let state = self.state.lock().await;
            state.target_wallet.clone()
        };

        // Mark target as visited
        visited.lock().await.insert(target_wallet.clone());

        // Get initial wallets to explore (from target's first hop)
        let initial_wallets: Vec<String> = {
            let state = self.state.lock().await;
            state.knowledge_graph.wallets.keys()
                .filter(|w| *w != &target_wallet)
                .cloned()
                .collect()
        };

        println!("\nğŸ” Starting CONCURRENT recursive exploration of {} initial wallets (max depth: {})...",
            initial_wallets.len(), max_depth);

        // Spawn independent recursive tasks for each wallet
        let mut tasks = Vec::new();

        for wallet in initial_wallets {
            let visited_clone = Arc::clone(&visited);
            let agent_clone = self.clone();

            let task = tokio::spawn(async move {
                agent_clone.explore_wallet_recursive(wallet, 1, max_depth, visited_clone).await
            });

            tasks.push(task);
        }

        // Wait for all recursive explorations to complete
        let results = futures::future::join_all(tasks).await;

        // Count successes
        let successful = results.iter().filter(|r| r.is_ok()).count();
        println!("\nâœ… Recursive exploration complete: {}/{} tasks succeeded", successful, results.len());

        Ok(())
    }

    /// Recursively explore a single wallet and its neighbors
    async fn explore_wallet_recursive(
        &self,
        wallet: String,
        current_depth: usize,
        max_depth: usize,
        visited: Arc<tokio::sync::Mutex<std::collections::HashSet<String>>>,
    ) -> Result<()> {
        // Check if already visited
        {
            let mut v = visited.lock().await;
            if v.contains(&wallet) {
                return Ok(());
            }
            v.insert(wallet.clone());
        }

        // Check if this is an exchange/treasury wallet
        let should_skip = {
            let state = self.state.lock().await;
            if let Some(node) = state.knowledge_graph.wallets.get(&wallet) {
                node.total_volume > 1_000_000_000.0
            } else {
                false
            }
        };

        if should_skip {
            println!("   [D{}] âš ï¸  {} - SKIP (exchange)", current_depth, &wallet[..8]);
            return Ok(());
        }

        // Fetch transfers for this wallet
        println!("   [D{}] ğŸ”„ {} - fetching...", current_depth, &wallet[..8]);

        let transfers_json = match self.fetch_wallet_transfers_filtered(&wallet).await {
            Ok(json) => {
                println!("   [D{}] âœ“ {} - fetched", current_depth, &wallet[..8]);
                json
            }
            Err(e) => {
                println!("   [D{}] âœ— {} - failed: {}", current_depth, &wallet[..8], e);
                return Ok(());
            }
        };

        // Process transfers and get new wallets discovered
        let new_wallets = match self.process_wallet_transfers(&transfers_json, current_depth).await {
            Ok(_) => {
                // Get newly discovered wallets from this processing
                let visited_set = visited.lock().await;
                let state = self.state.lock().await;
                state.knowledge_graph.wallets.keys()
                    .filter(|w| !visited_set.contains(*w))
                    .cloned()
                    .collect::<Vec<_>>()
            }
            Err(e) => {
                println!("   [D{}] âœ— {} - processing failed: {}", current_depth, &wallet[..8], e);
                return Ok(());
            }
        };

        println!("   [D{}] âœ“ {} - processed, found {} new wallets",
            current_depth, &wallet[..8], new_wallets.len());

        // If we haven't reached max depth, recursively explore neighbors CONCURRENTLY
        if current_depth < max_depth && !new_wallets.is_empty() {
            let tasks: Vec<_> = new_wallets.into_iter().map(|new_wallet| {
                self.explore_wallet_recursive(
                    new_wallet,
                    current_depth + 1,
                    max_depth,
                    Arc::clone(&visited),
                )
            }).collect();

            // Execute all child explorations concurrently
            futures::future::join_all(tasks).await;
        }

        Ok(())
    }

    /// Fetch transfers for a wallet with txType filter (sol,spl only)
    async fn fetch_wallet_transfers_filtered(&self, address: &str) -> Result<serde_json::Value> {
        // Generate OVSM script to call get_account_transfers with txType filter
        // Use smaller limit for faster exploration (we only need basic relationships)
        let ovsm_script = format!(r#"
(do
  (define transfers (get_account_transfers {{
    :address "{}"
    :limit 20
    :txType "sol,spl"
  }}))
  transfers)
"#, address);

        // Execute via OVSM service
        let mut ovsm = self.ovsm_service.lock().await;
        let result_value = ovsm.execute_code(&ovsm_script)
            .context("Failed to fetch wallet transfers")?;

        // Convert OVSM Value to JSON
        let result_json = self.value_to_json(result_value)?;

        Ok(result_json)
    }

    /// Find all paths from funding sources to target wallet using DFS
    fn find_all_paths(&self, state: &InvestigationState, max_depth: usize) -> Vec<WalletPath> {
        let mut all_paths = Vec::new();
        let target = &state.target_wallet;

        // Find all funding sources (wallets that sent TO target)
        let funding_sources: Vec<String> = state.knowledge_graph.relationships.iter()
            .filter(|rel| &rel.to == target && (rel.relationship_type == RelationshipType::Funding || rel.relationship_type == RelationshipType::SimpleTransfer))
            .map(|rel| rel.from.clone())
            .collect();

        // For each funding source, run DFS to find all paths to target
        for source in funding_sources {
            let mut visited = std::collections::HashSet::new();
            let mut current_path = Vec::new();
            self.dfs_find_paths(
                &source,
                target,
                &mut current_path,
                &mut visited,
                &mut all_paths,
                state,
                0,
                max_depth,
            );
        }

        // Also find outflow paths (from target to receivers)
        let receivers: Vec<String> = state.knowledge_graph.relationships.iter()
            .filter(|rel| &rel.from == target && rel.relationship_type == RelationshipType::SimpleTransfer)
            .map(|rel| rel.to.clone())
            .collect();

        for receiver in receivers {
            let mut visited = std::collections::HashSet::new();
            let mut current_path = Vec::new();
            self.dfs_find_paths(
                target,
                &receiver,
                &mut current_path,
                &mut visited,
                &mut all_paths,
                state,
                0,
                max_depth,
            );
        }

        // Rank paths by volume and recency
        all_paths.sort_by(|a, b| {
            // Sort by volume (descending)
            b.total_volume.partial_cmp(&a.total_volume).unwrap_or(std::cmp::Ordering::Equal)
        });

        all_paths
    }

    /// DFS helper to recursively find paths
    fn dfs_find_paths(
        &self,
        current: &str,
        target: &str,
        path: &mut Vec<PathHop>,
        visited: &mut std::collections::HashSet<String>,
        all_paths: &mut Vec<WalletPath>,
        state: &InvestigationState,
        depth: usize,
        max_depth: usize,
    ) {
        if depth > max_depth {
            return;
        }

        // Mark as visited
        visited.insert(current.to_string());

        // Find all relationships from current wallet
        let outgoing: Vec<&WalletRelationship> = state.knowledge_graph.relationships.iter()
            .filter(|rel| &rel.from == current && !visited.contains(&rel.to))
            .collect();

        for rel in outgoing {
            // Add this hop to the path
            path.push(PathHop {
                wallet: rel.to.clone(),
                amount: rel.volume,
                timestamp: state.knowledge_graph.wallets.get(&rel.to)
                    .and_then(|w| w.first_seen.clone()),
                depth,
            });

            // If we reached the target, save this path
            if &rel.to == target {
                let total_volume: f64 = path.iter().map(|h| h.amount).sum();
                let confidence = if rel.relationship_type == RelationshipType::RoundTrip { 0.95 } else { 0.70 };

                let path_type = if path.len() == 1 {
                    // Direct path
                    if state.knowledge_graph.relationships.iter().any(|r| &r.from == target && &r.to == current && r.relationship_type == RelationshipType::RoundTrip) {
                        PathType::RoundTrip
                    } else if path[0].wallet == *target {
                        PathType::Outflow
                    } else {
                        PathType::Inflow
                    }
                } else {
                    // Multi-hop path
                    PathType::Inflow
                };

                all_paths.push(WalletPath {
                    hops: path.clone(),
                    total_volume,
                    confidence,
                    most_recent_timestamp: path.last().and_then(|h| h.timestamp.clone()),
                    path_type,
                });
            } else {
                // Continue DFS
                self.dfs_find_paths(
                    &rel.to,
                    target,
                    path,
                    visited,
                    all_paths,
                    state,
                    depth + 1,
                    max_depth,
                );
            }

            // Backtrack
            path.pop();
        }

        // Unmark visited to allow other paths
        visited.remove(current);
    }

    /// Render knowledge graph as PATH-BASED ASCII tree visualization using TransferGraph
    fn render_ascii_graph(&self, state: &InvestigationState) -> String {
        // Create TransferGraph instance with custom config
        let config = RenderConfig {
            title: "WALLET RELATIONSHIP INVESTIGATION".to_string(),
            origin_icon: "ğŸ¦ FUNDING SOURCE".to_string(),
            target_icon: "ğŸ¯ TARGET WALLET".to_string(),
            node_icon: "â—‹".to_string(),
            show_header: true,
            show_paths_summary: true,
            show_stats_summary: true,
            address_truncate_length: 8,
        };

        let mut graph = TransferGraph::with_config(config);

        // Set target wallet
        graph.target = Some(state.target_wallet.clone());

        // Convert WalletRelationships to Transfers
        for rel in &state.knowledge_graph.relationships {
            // Determine the origin (first node in graph)
            if graph.origin.is_none() {
                // Set first funder as origin
                if rel.to == state.target_wallet {
                    graph.origin = Some(rel.from.clone());
                }
            }

            // Create transfer from relationship
            let transfer = Transfer {
                from: rel.from.clone(),
                to: rel.to.clone(),
                amount: rel.volume,
                token_symbol: "tokens".to_string(), // Could be enhanced with actual token symbol
                timestamp: state.knowledge_graph.wallets.get(&rel.from)
                    .and_then(|w| w.first_seen.clone()),
                note: Some(format!("{:?}", rel.relationship_type)),
            };

            graph.add_transfer(transfer);
        }

        // Set labels for known wallets
        for (addr, wallet_node) in &state.knowledge_graph.wallets {
            graph.set_node_label(addr, wallet_node.label.clone());
        }

        // Render the graph
        let mut output = graph.render_ascii();

        // Add additional analysis sections specific to blockchain investigation
        let all_paths = self.find_all_paths(state, 5);

        let roundtrip_paths: Vec<_> = all_paths.iter()
            .filter(|p| p.path_type == PathType::RoundTrip)
            .collect();

        // Add round-trip analysis (high-risk indicator)
        if !roundtrip_paths.is_empty() {
            output.push_str("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n");
            output.push_str("âš ï¸  ROUND-TRIP TRANSFER ANALYSIS (Same Owner Detection)\n\n");

            for (idx, path) in roundtrip_paths.iter().take(5).enumerate() {
                output.push_str(&format!("PATH #{} - BIDIRECTIONAL FLOW (Confidence: 95%)\n", idx + 1));
                output.push_str(&format!("   Volume: {:.2} tokens\n", path.total_volume));

                if !path.hops.is_empty() {
                    let first_hop = &path.hops[0];
                    let wallet_label = state.knowledge_graph.wallets.get(&first_hop.wallet)
                        .map(|w| w.label.as_str()).unwrap_or(&first_hop.wallet[..8]);
                    let target_short = format!("{}...{}", &state.target_wallet[..6], &state.target_wallet[state.target_wallet.len()-4..]);

                    output.push_str("   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
                    output.push_str(&format!("   â”‚  {} â•â•â¤ {}  â”‚\n", wallet_label, target_short));
                    output.push_str(&format!("   â”‚  {} â¬…â•â• {}  â”‚\n", wallet_label, target_short));
                    output.push_str("   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n");
                }
            }
        }

        // Coordination risk assessment
        let total_roundtrips = roundtrip_paths.len();
        let cluster_assessment = if total_roundtrips > 5 {
            "VERY HIGH - Coordinated bot network detected"
        } else if total_roundtrips > 2 {
            "HIGH - Multi-wallet coordination likely"
        } else if total_roundtrips > 0 {
            "MEDIUM - Some wallet clustering detected"
        } else {
            "LOW - Limited coordination evidence"
        };

        output.push_str("\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n");
        output.push_str("ğŸ” RISK ASSESSMENT\n\n");
        output.push_str("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
        output.push_str(&format!("â”‚ Coordination Risk: {:<54} â”‚\n", cluster_assessment));
        output.push_str(&format!("â”‚ Round-Trip Patterns: {:<52} â”‚\n", total_roundtrips));
        output.push_str(&format!("â”‚ Total Investigation Paths: {:<48} â”‚\n", all_paths.len()));
        output.push_str("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");

        if total_roundtrips > 0 {
            output.push_str("\nâš ï¸  WARNING: Round-trip transfers detected - high probability of same-owner control.\n");
        }

        output.push_str("\nâœ… INVESTIGATION COMPLETE!\n\n");

        output
    }

    /// Save knowledge graph to JSON-LD file
    async fn save_knowledge_graph(&self) -> Result<()> {
        let state = self.state.lock().await;
        let filename = format!("/tmp/wallet_graph_{}.jsonld",
                               &state.target_wallet[..8]);

        let json_ld = serde_json::to_string_pretty(&state.knowledge_graph)?;
        std::fs::write(&filename, json_ld)?;

        println!("\nğŸ’¾ Knowledge graph saved to: {}", filename);
        Ok(())
    }

    /// Execute current investigation phase
    async fn execute_phase(&self) -> Result<serde_json::Value> {
        let state = self.state.lock().await.clone();

        let ovsm_script = match state.phase {
            InvestigationPhase::Initial => self.generate_initial_script(&state.target_wallet),
            InvestigationPhase::BasicProfiling => self.generate_profiling_script(&state),
            InvestigationPhase::DeepAnalysis => self.generate_deep_analysis_script(&state),
            InvestigationPhase::PatternRecognition => self.generate_pattern_script(&state),
            InvestigationPhase::HypothesisTesting => self.generate_hypothesis_test_script(&state),
            InvestigationPhase::Synthesis => self.generate_synthesis_script(&state),
        };

        println!("? Executing OVSM script for phase: {:?}", state.phase);
        println!("Script preview: {}", &ovsm_script[..ovsm_script.len().min(200)]);

        // Execute OVSM script
        let mut ovsm = self.ovsm_service.lock().await;
        let result_value = ovsm.execute_code(&ovsm_script)
            .context("Failed to execute OVSM script")?;

        // Convert Value to serde_json::Value
        let result = self.value_to_json(result_value)?;

        // Store findings
        self.store_findings(result.clone()).await?;

        Ok(result)
    }

    /// Generate context-aware AI evaluation prompt based on current state
    async fn evaluate_findings(&self) -> Result<String> {
        let state = self.state.lock().await.clone();

        // Build dynamic system prompt based on investigation state
        let system_prompt = self.build_evaluation_prompt(&state);

        // Prepare findings summary for evaluation
        let findings_summary = serde_json::to_string_pretty(&state.findings)?;

        let user_prompt = format!(
            "Based on these findings from investigating wallet {}:\n\n{}\n\nCurrent hypotheses:\n{:?}\n\nPlease evaluate the significance of these findings and suggest next investigation steps.",
            state.target_wallet,
            findings_summary,
            state.hypotheses
        );

        println!("\n? Self-evaluating findings with AI...");

        // Call AI with custom system prompt
        let ai_service = self.ai_service.lock().await;
        let evaluation = ai_service.query_with_system_prompt(
            &system_prompt,
            &user_prompt
        ).await?;

        println!("? AI Evaluation:\n{}", &evaluation[..evaluation.len().min(500)]);

        Ok(evaluation)
    }

    /// Build dynamic system prompt based on investigation phase and findings
    fn build_evaluation_prompt(&self, state: &InvestigationState) -> String {
        let base_prompt = match state.phase {
            InvestigationPhase::Initial => {
                "You are a blockchain forensics expert beginning a wallet investigation. \
                Focus on identifying the wallet type (trader, bot, DeFi user, etc.) and \
                determining investigation priorities."
            }
            InvestigationPhase::BasicProfiling => {
                "You are analyzing wallet behavior patterns. Look for trading strategies, \
                interaction frequencies, preferred protocols, and potential automated behavior."
            }
            InvestigationPhase::DeepAnalysis => {
                "You are conducting deep blockchain analysis. Identify complex patterns, \
                multi-hop transactions, MEV activity, and sophisticated trading strategies."
            }
            InvestigationPhase::PatternRecognition => {
                "You are a pattern recognition specialist. Identify recurring behaviors, \
                temporal patterns, correlation with market events, and anomalies."
            }
            InvestigationPhase::HypothesisTesting => {
                "You are testing specific hypotheses about wallet behavior. Evaluate evidence \
                strength, identify contradictions, and refine understanding."
            }
            InvestigationPhase::Synthesis => {
                "You are synthesizing all findings into a comprehensive profile. Create a \
                complete picture of wallet activity and behavior patterns."
            }
        };

        format!(
            "{}\n\nInvestigation iteration: {}\nConfidence scores: {:?}\nEvidence collected: {} pieces\n\nYour task:\n1. Evaluate the significance of current findings\n2. Identify gaps in our understanding\n3. Suggest specific next investigation steps\n4. Rate confidence in current hypotheses\n5. Identify any red flags or unusual patterns\n\nRespond in JSON format with keys: significance, gaps, next_steps, confidence_updates, red_flags",
            base_prompt,
            state.iteration,
            state.confidence_scores,
            state.evidence.len()
        )
    }

    /// Decide whether to continue investigation based on AI evaluation
    async fn decide_next_steps(&self, evaluation: String) -> Result<bool> {
        // Parse AI evaluation (assuming JSON response)
        let eval_json: serde_json::Value = serde_json::from_str(&evaluation)
            .unwrap_or_else(|_| serde_json::json!({
                "next_steps": ["continue"],
                "significance": 0.5,
                "confidence_updates": {}
            }));

        let mut state = self.state.lock().await;

        // Update next steps from AI evaluation
        if let Some(steps) = eval_json["next_steps"].as_array() {
            state.next_steps = steps.iter()
                .filter_map(|s| s.as_str().map(String::from))
                .collect();
        }

        // Update confidence scores
        if let Some(updates) = eval_json["confidence_updates"].as_object() {
            for (key, value) in updates {
                if let Some(score) = value.as_f64() {
                    state.confidence_scores.insert(key.clone(), score);
                }
            }
        }

        // Advance phase based on current progress
        state.phase = self.determine_next_phase(&state.phase, &state.findings);

        // Continue if we have more steps and haven't reached synthesis
        Ok(!state.next_steps.is_empty() && !matches!(state.phase, InvestigationPhase::Synthesis))
    }

    /// Adapt investigation strategy based on findings
    async fn adapt_strategy(&self) -> Result<()> {
        let state = self.state.lock().await.clone();

        println!("\n? Adapting investigation strategy...");
        println!("  Current phase: {:?}", state.phase);
        println!("  Next steps: {:?}", state.next_steps);
        println!("  Confidence scores: {:?}", state.confidence_scores);

        // Generate new hypotheses based on findings
        if state.findings.len() > 3 && state.hypotheses.is_empty() {
            self.generate_hypotheses().await?;
        }

        Ok(())
    }

    /// Generate initial investigation script
    fn generate_initial_script(&self, wallet: &str) -> String {
        format!(
            r#"(do
  ;; Initial wallet investigation - minimal transfer aggregation
  (define target "{}")

  ;; Get basic wallet info (placeholders: getBalance, getSignaturesForAddress, getTokenAccountsByOwner)
  ;; Analyze transaction type with analyzeTransactionType helper

  ;; Fetch recent transfers (using actual MCP tool)
  (define resp (get_account_transfers {{:address target :limit 200}}))
  (define transfers (get resp "data"))

  ;; Split by direction
  (define inflows (filter transfers (lambda (t) (= (get t "transferType") "IN"))))
  (define outflows (filter transfers (lambda (t) (= (get t "transferType") "OUT"))))

  ;; Aggregate inflows by sender
  (define inflow_agg
    (reduce
      inflows
      {{}}
      (lambda (acc tx)
        (do
          (define from (get tx "from"))
          (define amt (float (get tx "tokenAmount")))
          (define existing (get acc from))
          (define current (if existing existing 0))
          (put acc from (+ current amt))))))

  ;; Aggregate outflows by receiver
  (define outflow_agg
    (reduce
      outflows
      {{}}
      (lambda (acc tx)
        (do
          (define to (get tx "to"))
          (define amt (float (get tx "tokenAmount")))
          (define existing (get acc to))
          (define current (if existing existing 0))
          (put acc to (+ current amt))))))

  ;; Sort and take top 5
  (define top_senders
    (take 5
      (sort
        (entries inflow_agg)
        (lambda (a b) (> (get a 1) (get b 1))))))

  (define top_receivers
    (take 5
      (sort
        (entries outflow_agg)
        (lambda (a b) (> (get a 1) (get b 1))))))

  ;; Count unique tokens
  (define unique_tokens (group-by transfers (lambda (tx) (get tx "mint"))))

  ;; Return results
  {{:wallet target
   :transfer_count (length transfers)
   :inflow_count (length inflows)
   :outflow_count (length outflows)
   :unique_tokens (length (entries unique_tokens))
   :top_5_senders top_senders
   :top_5_receivers top_receivers}}
)"#,
            wallet
        )
    }

    /// Generate profiling script based on initial findings
    fn generate_profiling_script(&self, state: &InvestigationState) -> String {
        format!(
            r#"(do
  ;; Deep profiling phase - analyze transfer patterns
  ;; Uses helpers: analyzeTemporalPatterns, filterDexTransactions
  (define target "{}")

  ;; Get more transfers for pattern analysis
  (define resp (get_account_transfers {{:address target :limit 500}}))
  (define transfers (get resp "data"))

  ;; Analyze token diversity
  (define by_token (group-by transfers (lambda (tx) (get tx "mint"))))
  (define token_count (length (entries by_token)))

  ;; Analyze transfer frequency (placeholder)
  (define avg_tx_per_token (/ (length transfers) (if (> token_count 0) token_count 1)))

  {{:wallet target
   :total_transfers_analyzed (length transfers)
   :unique_tokens token_count
   :avg_transfers_per_token avg_tx_per_token
   :analysis_phase "BasicProfiling"}}
)"#,
            state.target_wallet
        )
    }

    /// Generate deep analysis script for MEV and advanced patterns
    fn generate_deep_analysis_script(&self, state: &InvestigationState) -> String {
        format!(
            r#"(do
  ;; Deep analysis phase - placeholder until advanced tools available
  (define target "{}")

  ;; Return minimal placeholder - NO fake data keys
  {{:wallet target
   :analysis_phase "DeepAnalysis"
   :status "pending_tool_implementation"
   :note "Advanced MEV analysis requires specialized MCP tools"}}
)"#,
            state.target_wallet
        )
    }

    /// Generate pattern recognition script
    fn generate_pattern_script(&self, state: &InvestigationState) -> String {
        format!(
            r#"(do
  ;; Pattern recognition phase - placeholder until advanced tools available
  (define target "{}")

  ;; Return minimal placeholder - NO fake data keys
  {{:wallet target
   :analysis_phase "PatternRecognition"
   :status "pending_tool_implementation"
   :note "Pattern analysis requires temporal data and behavioral clustering tools"}}
)"#,
            state.target_wallet
        )
    }

    /// Generate hypothesis testing script
    fn generate_hypothesis_test_script(&self, state: &InvestigationState) -> String {
        format!(
            r#"(do
  ;; Hypothesis testing phase - placeholder until advanced tools available
  (define target "{}")

  ;; Return minimal placeholder - NO fake data keys
  {{:wallet target
   :analysis_phase "HypothesisTesting"
   :status "pending_tool_implementation"
   :note "Hypothesis validation requires comprehensive transaction graph analysis"}}
)"#,
            state.target_wallet
        )
    }

    /// Generate synthesis script to combine all findings
    fn generate_synthesis_script(&self, state: &InvestigationState) -> String {
        format!(
            r#"(do
  ;; Synthesis phase - placeholder until advanced tools available
  (define target "{}")

  ;; Return minimal placeholder - NO fake data keys
  {{:wallet target
   :analysis_phase "Synthesis"
   :status "pending_tool_implementation"
   :note "Final synthesis requires complete data from all investigation phases"}}
)"#,
            state.target_wallet
        )
    }

    /// Store findings from OVSM execution
    async fn store_findings(&self, result: serde_json::Value) -> Result<()> {
        let mut state = self.state.lock().await;

        // Calculate significance based on content
        let significance = self.calculate_finding_significance(&result, &state.phase);

        let finding = Finding {
            category: format!("{:?}", state.phase),
            description: self.extract_finding_description(&result, &state.phase),
            significance,
            raw_data: result,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)?
                .as_secs(),
        };

        state.findings.push(finding);
        Ok(())
    }

    /// Calculate significance of a finding based on its content
    fn calculate_finding_significance(&self, result: &serde_json::Value, phase: &InvestigationPhase) -> f64 {
        let mut significance = 0.5; // Base significance

        // Adjust based on phase
        match phase {
            InvestigationPhase::Initial => significance *= 0.8,
            InvestigationPhase::BasicProfiling => significance *= 0.9,
            InvestigationPhase::DeepAnalysis => significance *= 1.1,
            InvestigationPhase::PatternRecognition => significance *= 1.2,
            InvestigationPhase::HypothesisTesting => significance *= 1.3,
            InvestigationPhase::Synthesis => significance *= 1.5,
        }

        // Check for key indicators in the result
        if let Some(obj) = result.as_object() {
            // High significance indicators
            if obj.contains_key("mev_activity") {
                significance += 0.2;
            }
            if obj.contains_key("anomalies") {
                if let Some(anomalies) = obj.get("anomalies").and_then(|v| v.as_array()) {
                    significance += 0.1 * (anomalies.len() as f64).min(3.0) / 3.0;
                }
            }
            if obj.get("wash_trading_detected").and_then(|v| v.as_bool()).unwrap_or(false) {
                significance += 0.3;
            }
            if obj.contains_key("risk_assessment") {
                significance += 0.15;
            }

            // Adjust based on data volume
            if let Some(activity) = obj.get("recent_activity").and_then(|v| v.as_u64()) {
                significance *= 1.0 + (activity as f64 / 1000.0).min(0.5);
            }
        }

        significance.min(1.0).max(0.1) // Clamp between 0.1 and 1.0
    }

    /// Extract a descriptive summary of the finding
    fn extract_finding_description(&self, result: &serde_json::Value, phase: &InvestigationPhase) -> String {
        let base_desc = match phase {
            InvestigationPhase::Initial => "Initial wallet profiling completed",
            InvestigationPhase::BasicProfiling => "Basic behavior analysis completed",
            InvestigationPhase::DeepAnalysis => "Deep MEV and pattern analysis completed",
            InvestigationPhase::PatternRecognition => "Pattern recognition analysis completed",
            InvestigationPhase::HypothesisTesting => "Hypothesis testing completed",
            InvestigationPhase::Synthesis => "Investigation synthesis completed",
        };

        // Add specific details from the result
        if let Some(obj) = result.as_object() {
            let mut details = Vec::new();

            if let Some(balance) = obj.get("balance").and_then(|v| v.as_f64()) {
                details.push(format!("Balance: {:.2} SOL", balance / 1e9));
            }
            if let Some(count) = obj.get("recent_activity").and_then(|v| v.as_u64()) {
                details.push(format!("{} recent transactions", count));
            }
            if let Some(mev) = obj.get("mev_activity").and_then(|v| v.as_object()) {
                if !mev.is_empty() {
                    details.push("MEV activity detected".to_string());
                }
            }
            if obj.get("wash_trading_detected").and_then(|v| v.as_bool()).unwrap_or(false) {
                details.push("Wash trading patterns detected".to_string());
            }

            if !details.is_empty() {
                format!("{}: {}", base_desc, details.join(", "))
            } else {
                base_desc.to_string()
            }
        } else {
            base_desc.to_string()
        }
    }

    /// Generate hypotheses based on findings
    async fn generate_hypotheses(&self) -> Result<()> {
        let mut state = self.state.lock().await;

        // Analyze findings to generate hypotheses
        let mut hypotheses = Vec::new();

        // Analyze transaction patterns
        let mut regular_intervals = 0;
        let mut high_frequency = 0;
        let mut mev_activity = 0;
        let mut dex_focus = 0;

        for finding in &state.findings {
            let data = &finding.raw_data;

            // Check for automated behavior indicators
            if let Some(patterns) = data.get("periodic_activity") {
                if patterns.is_object() || patterns.is_array() {
                    regular_intervals += 1;
                }
            }

            // Check for high-frequency trading
            if let Some(activity) = data.get("recent_activity").and_then(|v| v.as_u64()) {
                if activity > 100 {
                    high_frequency += 1;
                }
            }

            // Check for MEV activity
            if data.get("mev_activity").is_some() {
                mev_activity += 1;
            }

            // Check for DEX interactions
            if let Some(programs) = data.get("program_interactions").and_then(|v| v.as_object()) {
                for (program, _) in programs {
                    if program.contains("serum") || program.contains("raydium") || program.contains("orca") {
                        dex_focus += 1;
                        break;
                    }
                }
            }
        }

        // Generate hypotheses based on evidence
        if regular_intervals > 0 || high_frequency > 1 {
            hypotheses.push(Hypothesis {
                statement: "This wallet exhibits automated trading behavior".to_string(),
                confidence: (regular_intervals as f64 * 0.3 + high_frequency as f64 * 0.2).min(0.9),
                supporting_evidence: vec![
                    if regular_intervals > 0 { Some("Regular transaction intervals detected".to_string()) } else { None },
                    if high_frequency > 0 { Some(format!("High transaction frequency observed")) } else { None },
                ].into_iter().flatten().collect(),
                contradicting_evidence: vec![],
            });
        }

        if mev_activity > 0 {
            hypotheses.push(Hypothesis {
                statement: "This wallet engages in MEV extraction strategies".to_string(),
                confidence: (mev_activity as f64 * 0.4).min(0.85),
                supporting_evidence: vec![
                    "MEV activity patterns detected".to_string(),
                    if dex_focus > 0 { "Heavy DEX interaction observed".to_string() } else { "".to_string() },
                ].into_iter().filter(|s| !s.is_empty()).collect(),
                contradicting_evidence: vec![],
            });
        }

        if dex_focus > 1 && mev_activity == 0 {
            hypotheses.push(Hypothesis {
                statement: "This wallet is primarily a DEX trader or liquidity provider".to_string(),
                confidence: (dex_focus as f64 * 0.25).min(0.75),
                supporting_evidence: vec![
                    "Multiple DEX protocol interactions".to_string(),
                    "Focus on decentralized exchange activity".to_string(),
                ],
                contradicting_evidence: if mev_activity == 0 {
                    vec!["No MEV extraction patterns found".to_string()]
                } else {
                    vec![]
                },
            });
        }

        // Default hypothesis if no specific patterns found
        if hypotheses.is_empty() {
            hypotheses.push(Hypothesis {
                statement: "This wallet exhibits standard user trading patterns".to_string(),
                confidence: 0.5,
                supporting_evidence: vec!["Transaction activity within normal parameters".to_string()],
                contradicting_evidence: vec![],
            });
        }

        // Add all generated hypotheses to state
        for hypothesis in hypotheses {
            state.hypotheses.push(hypothesis);
        }

        Ok(())
    }

    /// Determine next investigation phase
    fn determine_next_phase(
        &self,
        current: &InvestigationPhase,
        findings: &[Finding],
    ) -> InvestigationPhase {
        match current {
            InvestigationPhase::Initial if findings.len() >= 1 => InvestigationPhase::BasicProfiling,
            InvestigationPhase::BasicProfiling if findings.len() >= 2 => InvestigationPhase::DeepAnalysis,
            InvestigationPhase::DeepAnalysis if findings.len() >= 4 => InvestigationPhase::PatternRecognition,
            InvestigationPhase::PatternRecognition if findings.len() >= 6 => InvestigationPhase::HypothesisTesting,
            InvestigationPhase::HypothesisTesting => InvestigationPhase::Synthesis,
            _ => current.clone(),
        }
    }

    /// Convert OVSM Value to JSON
    fn value_to_json(&self, value: Value) -> Result<serde_json::Value> {
        use serde_json::json;

        let json = match value {
            Value::Null => json!(null),
            Value::Bool(b) => json!(b),
            Value::Int(i) => json!(i),
            Value::Float(f) => json!(f),
            Value::String(s) => json!(s),
            Value::Array(arr) => {
                let json_array: Result<Vec<_>> = arr.iter()
                    .map(|v| self.value_to_json(v.clone()))
                    .collect();
                json!(json_array?)
            }
            Value::Object(map) => {
                let mut json_map = serde_json::Map::new();
                for (k, v) in map.iter() {
                    json_map.insert(k.clone(), self.value_to_json(v.clone())?);
                }
                json!(json_map)
            }
            _ => {
                // For other Value types, convert to string representation
                json!(format!("{:?}", value))
            }
        };

        Ok(json)
    }

    /// Generate final investigation report
    async fn generate_final_report(&self) -> Result<String> {
        let state = self.state.lock().await;

        let findings_list = state.findings.iter()
            .map(|f| format!("- {}: {}", f.category, f.description))
            .collect::<Vec<_>>()
            .join("\n");

        let hypotheses_list = state.hypotheses.iter()
            .map(|h| format!("- {} (confidence: {:.2})", h.statement, h.confidence))
            .collect::<Vec<_>>()
            .join("\n");

        let mut report = String::new();
        report.push_str("# Wallet Investigation Report\n\n");
        report.push_str(&format!("**Target Wallet:** {}\n", state.target_wallet));
        report.push_str(&format!("**Iterations:** {}\n", state.iteration));
        report.push_str(&format!("**Findings:** {} collected\n\n", state.findings.len()));
        report.push_str("## Executive Summary\n\n");
        report.push_str(&format!("Based on {} iterations of investigation with self-evaluation, we have identified:\n\n", state.iteration));
        report.push_str("## Key Findings\n");
        report.push_str(&findings_list);
        report.push_str("\n\n## Hypotheses\n");
        report.push_str(&hypotheses_list);
        report.push_str(&format!("\n\n## Confidence Scores\n{:?}\n\n", state.confidence_scores));
        report.push_str("## Evidence Summary\n");
        report.push_str(&format!("- Total evidence pieces: {}\n", state.evidence.len()));
        report.push_str(&format!("- Investigation phases completed: {:?}", state.phase));

        Ok(report)
    }
}

/// Extension trait for AiService to support custom system prompts
impl AiService {
    pub async fn query_with_system_prompt(
        &self,
        system_prompt: &str,
        user_prompt: &str,
    ) -> Result<String> {
        // Use the query_osvm_ai_with_options method to include system prompt
        // IMPORTANT: Use ownPlan=true to bypass planning and use our custom system prompt directly
        self.query_osvm_ai_with_options(
            user_prompt,
            Some(system_prompt.to_string()),
            Some(true),  // ownPlan=true - use custom system prompt, bypass planning
            false  // debug
        ).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use tokio::sync::Mutex;

    // Helper function to create test research agent
    async fn create_test_agent() -> ResearchAgent {
        let ai_service = Arc::new(Mutex::new(
            AiService::new()
        ));
        let ovsm_service = Arc::new(Mutex::new(OvsmService::new()));

        ResearchAgent::new(
            ai_service,
            ovsm_service,
            "TestWallet123".to_string()
        )
    }

    // Helper function to create minimal valid test state
    fn create_test_state(wallet: &str, phase: InvestigationPhase) -> InvestigationState {
        InvestigationState {
            target_wallet: wallet.to_string(),
            phase,
            findings: vec![],
            hypotheses: vec![],
            evidence: HashMap::new(),
            next_steps: vec![],
            confidence_scores: HashMap::new(),
            iteration: 1,
            investigation_todos: vec![],
            current_reasoning: String::new(),
            knowledge_graph: WalletKnowledgeGraph {
                context: "https://schema.org/".to_string(),
                graph_type: "WalletRelationshipGraph".to_string(),
                wallets: HashMap::new(),
                relationships: vec![],
            },
        }
    }

    // Helper to create test state with knowledge graph
    fn create_test_state_with_graph(wallet: &str) -> InvestigationState {
        let mut wallets = HashMap::new();

        // Target wallet
        wallets.insert(wallet.to_string(), WalletNode {
            id: wallet.to_string(),
            node_type: "Wallet".to_string(),
            label: "Target Wallet".to_string(),
            first_seen: Some("2024-01-01T00:00:00Z".to_string()),
            total_volume: 50000.0,
            wallet_type: "target".to_string(),
        });

        // Funding source
        wallets.insert("FundingSource123".to_string(), WalletNode {
            id: "FundingSource123".to_string(),
            node_type: "Wallet".to_string(),
            label: "Exchange Wallet".to_string(),
            first_seen: Some("2023-12-01T00:00:00Z".to_string()),
            total_volume: 100000.0,
            wallet_type: "funding_source".to_string(),
        });

        // Receiver
        wallets.insert("ReceiverABC".to_string(), WalletNode {
            id: "ReceiverABC".to_string(),
            node_type: "Wallet".to_string(),
            label: "Output Wallet".to_string(),
            first_seen: Some("2024-01-15T00:00:00Z".to_string()),
            total_volume: 25000.0,
            wallet_type: "receiver".to_string(),
        });

        let relationships = vec![
            WalletRelationship {
                rel_type: "Transfer".to_string(),
                from: "FundingSource123".to_string(),
                to: wallet.to_string(),
                relationship_type: RelationshipType::Funding,
                volume: 50000.0,
                tx_count: 5,
                confidence: 0.7,
            },
            WalletRelationship {
                rel_type: "Transfer".to_string(),
                from: wallet.to_string(),
                to: "ReceiverABC".to_string(),
                relationship_type: RelationshipType::SimpleTransfer,
                volume: 25000.0,
                tx_count: 3,
                confidence: 0.6,
            },
        ];

        InvestigationState {
            target_wallet: wallet.to_string(),
            phase: InvestigationPhase::DeepAnalysis,
            findings: vec![],
            hypotheses: vec![],
            evidence: HashMap::new(),
            next_steps: vec![],
            confidence_scores: HashMap::new(),
            iteration: 2,
            investigation_todos: vec![],
            current_reasoning: "Testing graph visualization".to_string(),
            knowledge_graph: WalletKnowledgeGraph {
                context: "https://schema.org/".to_string(),
                graph_type: "WalletRelationshipGraph".to_string(),
                wallets,
                relationships,
            },
        }
    }

    #[tokio::test]
    async fn test_initial_state() {
        let agent = create_test_agent().await;
        let state = agent.state.lock().await;

        assert_eq!(state.target_wallet, "TestWallet123");
        assert!(matches!(state.phase, InvestigationPhase::Initial));
        assert_eq!(state.iteration, 0);
        assert!(state.findings.is_empty());
        assert!(state.hypotheses.is_empty());
        assert_eq!(state.next_steps.len(), 3);
    }

    #[tokio::test]
    async fn test_generate_initial_script() {
        let agent = create_test_agent().await;
        let script = agent.generate_initial_script("TestWallet");

        assert!(script.contains("TestWallet"));
        assert!(script.contains("getBalance"));
        assert!(script.contains("getSignaturesForAddress"));
        assert!(script.contains("getTokenAccountsByOwner"));
        assert!(script.contains("analyzeTransactionType"));
    }

    #[tokio::test]
    async fn test_generate_profiling_script() {
        let agent = create_test_agent().await;
        let state = create_test_state("TestWallet", InvestigationPhase::BasicProfiling);

        let script = agent.generate_profiling_script(&state);

        assert!(script.contains("TestWallet"));
        assert!(script.contains("Deep profiling"));
        assert!(script.contains("analyzeTemporalPatterns"));
        assert!(script.contains("filterDexTransactions"));
    }

    #[tokio::test]
    async fn test_generate_deep_analysis_script() {
        let agent = create_test_agent().await;
        let state = create_test_state("MEVWallet", InvestigationPhase::DeepAnalysis);

        let script = agent.generate_deep_analysis_script(&state);

        assert!(script.contains("MEVWallet"));
        assert!(script.contains("MEV"));
        assert!(script.contains("sandwich"));
        assert!(script.contains("arbitrage"));
        assert!(script.contains("wash"));
        assert!(script.contains("multi-hop"));
    }

    #[tokio::test]
    async fn test_generate_pattern_script() {
        let agent = create_test_agent().await;
        let state = create_test_state("PatternWallet", InvestigationPhase::PatternRecognition);

        let script = agent.generate_pattern_script(&state);

        assert!(script.contains("PatternWallet"));
        assert!(script.contains("Pattern recognition"));
        assert!(script.contains("placeholder"));
        assert!(script.contains("analysis_phase"));
        assert!(script.contains("anomalies"));
    }

    #[tokio::test]
    async fn test_hypothesis_generation_with_mev() {
        let agent = create_test_agent().await;

        // Add findings with MEV activity
        {
            let mut state = agent.state.lock().await;
            state.findings.push(Finding {
                category: "DeepAnalysis".to_string(),
                description: "MEV activity detected".to_string(),
                significance: 0.8,
                raw_data: serde_json::json!({
                    "mev_activity": {"sandwich_attacks": 5},
                    "recent_activity": 150
                }),
                timestamp: 1234567890,
            });
        }

        agent.generate_hypotheses().await.unwrap();

        let state = agent.state.lock().await;
        assert!(!state.hypotheses.is_empty());

        let mev_hypothesis = state.hypotheses.iter()
            .find(|h| h.statement.contains("MEV"))
            .expect("Should have MEV hypothesis");

        assert!(mev_hypothesis.confidence > 0.3);
        assert!(!mev_hypothesis.supporting_evidence.is_empty());
    }

    #[tokio::test]
    async fn test_hypothesis_generation_with_automated_behavior() {
        let agent = create_test_agent().await;

        // Add findings indicating automated behavior
        {
            let mut state = agent.state.lock().await;
            state.findings.push(Finding {
                category: "PatternRecognition".to_string(),
                description: "Regular patterns detected".to_string(),
                significance: 0.7,
                raw_data: serde_json::json!({
                    "periodic_activity": {"interval": 300},
                    "recent_activity": 500
                }),
                timestamp: 1234567890,
            });
        }

        agent.generate_hypotheses().await.unwrap();

        let state = agent.state.lock().await;
        let automated_hypothesis = state.hypotheses.iter()
            .find(|h| h.statement.contains("automated"))
            .expect("Should have automation hypothesis");

        assert!(automated_hypothesis.confidence > 0.2);
    }

    #[tokio::test]
    async fn test_calculate_finding_significance() {
        let agent = create_test_agent().await;

        // Test with MEV activity
        let mev_result = serde_json::json!({
            "mev_activity": {"sandwich_attacks": 10},
            "wash_trading_detected": true
        });

        let significance = agent.calculate_finding_significance(
            &mev_result,
            &InvestigationPhase::DeepAnalysis
        );

        assert!(significance > 0.7, "MEV + wash trading should have high significance");

        // Test with normal activity
        let normal_result = serde_json::json!({
            "balance": 1000000000,
            "recent_activity": 10
        });

        let normal_significance = agent.calculate_finding_significance(
            &normal_result,
            &InvestigationPhase::Initial
        );

        assert!(normal_significance < 0.6, "Normal activity should have lower significance");
    }

    #[tokio::test]
    async fn test_extract_finding_description() {
        let agent = create_test_agent().await;

        let result = serde_json::json!({
            "balance": 5000000000.0,
            "recent_activity": 42,
            "mev_activity": {"arbitrage": 3},
            "wash_trading_detected": true
        });

        let description = agent.extract_finding_description(
            &result,
            &InvestigationPhase::DeepAnalysis
        );

        assert!(description.contains("Deep MEV"));
        assert!(description.contains("5.00 SOL"));
        assert!(description.contains("42 recent"));
        assert!(description.contains("MEV activity"));
        assert!(description.contains("Wash trading"));
    }

    #[tokio::test]
    async fn test_phase_transitions() {
        let agent = create_test_agent().await;

        // Add findings to trigger phase transitions
        {
            let mut state = agent.state.lock().await;

            // Initial phase with 1 finding
            assert!(matches!(state.phase, InvestigationPhase::Initial));

            state.findings.push(Finding {
                category: "Initial".to_string(),
                description: "Test".to_string(),
                significance: 0.5,
                raw_data: serde_json::json!({}),
                timestamp: 1,
            });
        }

        let next_phase = agent.determine_next_phase(
            &InvestigationPhase::Initial,
            &vec![Finding {
                category: "test".to_string(),
                description: "test".to_string(),
                significance: 0.5,
                raw_data: serde_json::json!({}),
                timestamp: 1,
            }]
        );

        assert!(matches!(next_phase, InvestigationPhase::BasicProfiling));
    }

    #[tokio::test]
    async fn test_build_evaluation_prompt() {
        let agent = create_test_agent().await;
        let mut state = create_test_state("TestWallet", InvestigationPhase::HypothesisTesting);
        state.confidence_scores = HashMap::from([
            ("test_score".to_string(), 0.75)
        ]);
        state.iteration = 5;

        let prompt = agent.build_evaluation_prompt(&state);

        assert!(prompt.contains("testing specific hypotheses"));
        assert!(prompt.contains("iteration: 5"));
        assert!(prompt.contains("test_score"));
        assert!(prompt.contains("0.75"));
        assert!(prompt.contains("JSON format"));
    }

    #[tokio::test]
    async fn test_value_to_json_conversion() {
        let agent = create_test_agent().await;

        // Test various Value types
        let null_value = Value::Null;
        assert_eq!(agent.value_to_json(null_value).unwrap(), serde_json::Value::Null);

        let bool_value = Value::Bool(true);
        assert_eq!(agent.value_to_json(bool_value).unwrap(), serde_json::json!(true));

        let int_value = Value::Int(42);
        assert_eq!(agent.value_to_json(int_value).unwrap(), serde_json::json!(42));

        let float_value = Value::Float(3.14);
        assert_eq!(agent.value_to_json(float_value).unwrap(), serde_json::json!(3.14));

        let string_value = Value::String("test".to_string());
        assert_eq!(agent.value_to_json(string_value).unwrap(), serde_json::json!("test"));
    }

    #[tokio::test]
    async fn test_hypothesis_test_script_generation() {
        let agent = create_test_agent().await;

        let mut state = create_test_state("TestWallet", InvestigationPhase::HypothesisTesting);
        state.hypotheses = vec![
            Hypothesis {
                statement: "Bot trader".to_string(),
                confidence: 0.7,
                supporting_evidence: vec!["Regular intervals".to_string()],
                contradicting_evidence: vec![],
            },
            Hypothesis {
                statement: "MEV searcher".to_string(),
                confidence: 0.6,
                supporting_evidence: vec!["Sandwich patterns".to_string()],
                contradicting_evidence: vec!["Low profit".to_string()],
            }
        ];
        state.iteration = 3;

        let script = agent.generate_hypothesis_test_script(&state);

        assert!(script.contains("TestWallet"));
        assert!(script.contains("Hypothesis testing"));
        assert!(script.contains("placeholder"));
        assert!(script.contains("hypotheses_tested 2"));
        assert!(script.contains("analysis_phase"));
    }

    #[tokio::test]
    async fn test_synthesis_script_generation() {
        let agent = create_test_agent().await;

        let mut state = create_test_state("SynthesisWallet", InvestigationPhase::Synthesis);
        state.findings = vec![
            Finding {
                category: "Initial".to_string(),
                description: "Basic profile".to_string(),
                significance: 0.5,
                raw_data: serde_json::json!({}),
                timestamp: 1,
            },
            Finding {
                category: "DeepAnalysis".to_string(),
                description: "MEV detected".to_string(),
                significance: 0.8,
                raw_data: serde_json::json!({}),
                timestamp: 2,
            }
        ];
        state.hypotheses = vec![
            Hypothesis {
                statement: "Professional trader".to_string(),
                confidence: 0.85,
                supporting_evidence: vec![],
                contradicting_evidence: vec![],
            }
        ];
        state.iteration = 10;

        let script = agent.generate_synthesis_script(&state);

        assert!(script.contains("SynthesisWallet"));
        assert!(script.contains("Synthesis phase"));
        assert!(script.contains("placeholder"));
        assert!(script.contains("findings_count 2"));
        assert!(script.contains("hypotheses_tested 1"));
        assert!(script.contains("iteration 10"));
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TransferGraph Visualization Tests
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    #[test]
    fn test_transfer_graph_basic() {
        let mut graph = TransferGraph::new();

        graph.add_transfer(Transfer {
            from: "Wallet_A".to_string(),
            to: "Wallet_B".to_string(),
            amount: 1000.50,
            token_symbol: "SOL".to_string(),
            timestamp: Some("2024-01-01T12:00:00Z".to_string()),
            note: Some("Test transfer".to_string()),
        });

        assert_eq!(graph.nodes.len(), 2);
        assert!(graph.nodes.contains_key("Wallet_A"));
        assert!(graph.nodes.contains_key("Wallet_B"));
    }

    #[test]
    fn test_transfer_graph_path_finding() {
        let mut graph = TransferGraph::new();

        // Create chain: A -> B -> C
        graph.add_transfer(Transfer {
            from: "A".to_string(),
            to: "B".to_string(),
            amount: 100.0,
            token_symbol: "SOL".to_string(),
            timestamp: None,
            note: None,
        });

        graph.add_transfer(Transfer {
            from: "B".to_string(),
            to: "C".to_string(),
            amount: 50.0,
            token_symbol: "SOL".to_string(),
            timestamp: None,
            note: None,
        });

        let paths = graph.find_paths("A", "C");
        assert_eq!(paths.len(), 1);
        assert_eq!(paths[0], vec!["A", "B", "C"]);
    }

    #[test]
    fn test_transfer_graph_multi_hop() {
        let mut graph = TransferGraph::new();

        // Create diamond pattern:
        //    A
        //   / \
        //  B   C
        //   \ /
        //    D
        graph.add_transfer(Transfer {
            from: "A".to_string(),
            to: "B".to_string(),
            amount: 100.0,
            token_symbol: "SOL".to_string(),
            timestamp: None,
            note: None,
        });

        graph.add_transfer(Transfer {
            from: "A".to_string(),
            to: "C".to_string(),
            amount: 100.0,
            token_symbol: "SOL".to_string(),
            timestamp: None,
            note: None,
        });

        graph.add_transfer(Transfer {
            from: "B".to_string(),
            to: "D".to_string(),
            amount: 50.0,
            token_symbol: "SOL".to_string(),
            timestamp: None,
            note: None,
        });

        graph.add_transfer(Transfer {
            from: "C".to_string(),
            to: "D".to_string(),
            amount: 50.0,
            token_symbol: "SOL".to_string(),
            timestamp: None,
            note: None,
        });

        let paths = graph.find_paths("A", "D");
        assert_eq!(paths.len(), 2); // Two paths: A->B->D and A->C->D
    }

    #[test]
    fn test_transfer_graph_format_amount() {
        let graph = TransferGraph::new();

        assert_eq!(graph.format_amount(1234.56), "1,234.56");
        assert_eq!(graph.format_amount(1000000.99), "1,000,000.99");
        assert_eq!(graph.format_amount(42.00), "42.00");
    }

    #[test]
    fn test_transfer_graph_truncate_address() {
        let graph = TransferGraph::new();

        let long_addr = "ABC123DEF456GHI789JKL012MNO345PQR678STU901VWX234";
        // Truncate keeps 'keep' chars from start and 'keep' from end
        assert_eq!(graph.truncate_address(long_addr, 8), "ABC123DE...01VWX234");

        let short_addr = "ABC123";
        assert_eq!(graph.truncate_address(short_addr, 8), "ABC123");
    }

    #[test]
    fn test_transfer_graph_with_labels() {
        let mut graph = TransferGraph::new();

        graph.add_transfer(Transfer {
            from: "Wallet_Origin".to_string(),
            to: "Wallet_Target".to_string(),
            amount: 5000.0,
            token_symbol: "USDC".to_string(),
            timestamp: Some("2024-01-15T10:30:00Z".to_string()),
            note: Some("Exchange deposit".to_string()),
        });

        graph.set_node_label("Wallet_Origin", "Binance Hot Wallet".to_string());
        graph.set_node_label("Wallet_Target", "User Trading Account".to_string());

        assert_eq!(
            graph.nodes.get("Wallet_Origin").unwrap().label,
            Some("Binance Hot Wallet".to_string())
        );
    }

    #[test]
    fn test_transfer_graph_render_config() {
        let config = RenderConfig {
            title: "TEST VISUALIZATION".to_string(),
            origin_icon: "ğŸŸ¢ START".to_string(),
            target_icon: "ğŸ”´ END".to_string(),
            node_icon: "â—".to_string(),
            show_header: true,
            show_paths_summary: false,
            show_stats_summary: true,
            address_truncate_length: 6,
        };

        let graph = TransferGraph::with_config(config.clone());
        assert_eq!(graph.render_config.title, "TEST VISUALIZATION");
        assert_eq!(graph.render_config.address_truncate_length, 6);
    }

    #[test]
    fn test_transfer_graph_ascii_rendering() {
        let mut graph = TransferGraph::new();
        graph.token_name = Some("USDC".to_string());
        graph.token_mint = Some("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v".to_string());
        graph.origin = Some("Origin_Wallet_123".to_string());
        graph.target = Some("Target_Wallet_456".to_string());

        graph.add_transfer(Transfer {
            from: "Origin_Wallet_123".to_string(),
            to: "Intermediate_789".to_string(),
            amount: 10000.0,
            token_symbol: "USDC".to_string(),
            timestamp: Some("2024-01-01".to_string()),
            note: None,
        });

        graph.add_transfer(Transfer {
            from: "Intermediate_789".to_string(),
            to: "Target_Wallet_456".to_string(),
            amount: 8500.0,
            token_symbol: "USDC".to_string(),
            timestamp: Some("2024-01-02".to_string()),
            note: Some("Final hop".to_string()),
        });

        let output = graph.render_ascii();

        // Verify key elements in output
        assert!(output.contains("TOKEN DISTRIBUTION TRACE"));
        assert!(output.contains("USDC"));
        assert!(output.contains("Target_Wallet_456"));
        assert!(output.contains("10,000.00")); // Formatted amount
        assert!(output.contains("Total Nodes:"));
        assert!(output.contains("Total Transfers:"));
    }

    #[test]
    fn test_render_ascii_graph_with_knowledge_graph() {
        let agent_future = create_test_agent();
        let rt = tokio::runtime::Runtime::new().unwrap();
        let agent = rt.block_on(agent_future);

        let state = create_test_state_with_graph("TargetWallet123");

        let output = agent.render_ascii_graph(&state);

        // Verify visualization contains key elements
        assert!(output.contains("WALLET RELATIONSHIP INVESTIGATION"));
        assert!(output.contains("RISK ASSESSMENT"));
        assert!(output.contains("Exchange Wallet")); // Label from mock data
        assert!(output.contains("Output Wallet"));   // Label from mock data
        assert!(output.contains("50,000.00"));       // Formatted funding volume
        assert!(output.contains("25,000.00"));       // Formatted outflow volume
        assert!(output.contains("Coordination Risk:"));

        println!("\n{}", output); // Print for manual inspection
    }

    #[test]
    fn test_transfer_graph_complex_scenario() {
        // Complex scenario: Exchange -> Target -> Multiple outputs with labels
        let config = RenderConfig {
            title: "COMPLEX WALLET INVESTIGATION".to_string(),
            origin_icon: "ğŸ¦ EXCHANGE".to_string(),
            target_icon: "ğŸ¯ SUSPECT".to_string(),
            node_icon: "â—‹".to_string(),
            show_header: true,
            show_paths_summary: true,
            show_stats_summary: true,
            address_truncate_length: 8,
        };

        let mut graph = TransferGraph::with_config(config);
        graph.origin = Some("ExchangeHotWallet1234567890ABCDEF".to_string());
        graph.target = Some("SuspectWalletAAAABBBBCCCCDDDD".to_string());
        graph.token_name = Some("SVMAI".to_string());

        // Initial funding from exchange
        graph.add_transfer(Transfer {
            from: "ExchangeHotWallet1234567890ABCDEF".to_string(),
            to: "SuspectWalletAAAABBBBCCCCDDDD".to_string(),
            amount: 100000.0,
            token_symbol: "SVMAI".to_string(),
            timestamp: Some("2024-12-01T08:00:00Z".to_string()),
            note: Some("Initial funding".to_string()),
        });

        // Suspect distributes to multiple wallets
        for i in 1..=3 {
            graph.add_transfer(Transfer {
                from: "SuspectWalletAAAABBBBCCCCDDDD".to_string(),
                to: format!("OutputWallet{}_XYZ", i),
                amount: 30000.0,
                token_symbol: "SVMAI".to_string(),
                timestamp: Some(format!("2024-12-{:02}T12:00:00Z", i + 1)),
                note: Some(format!("Distribution #{}", i)),
            });
        }

        // Set labels
        graph.set_node_label("ExchangeHotWallet1234567890ABCDEF", "Binance Deposit".to_string());
        graph.set_node_label("SuspectWalletAAAABBBBCCCCDDDD", "Investigation Target".to_string());
        graph.set_node_label("OutputWallet1_XYZ", "Mixer Entry".to_string());
        graph.set_node_label("OutputWallet2_XYZ", "DEX Trader".to_string());
        graph.set_node_label("OutputWallet3_XYZ", "Cold Storage".to_string());

        let output = graph.render_ascii();

        // Print first for debugging
        println!("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        println!("â•‘           COMPLEX SCENARIO VISUALIZATION DEMO                â•‘");
        println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
        println!("{}", output);

        // Verify complex scenario elements
        assert!(output.contains("COMPLEX WALLET INVESTIGATION"));
        assert!(output.contains("SVMAI"));
        assert!(output.contains("100,000.00"));
        assert!(output.contains("30,000.00"));
        assert!(output.contains("Binance Deposit"));
        assert!(output.contains("Investigation Target"));
        assert!(output.contains("Mixer Entry"));
        assert!(output.contains("DEX Trader"));
        assert!(output.contains("Cold Storage"));
        assert!(output.contains("Total Nodes:")); // Just check it exists, not the exact count
        assert!(output.contains("Total Transfers:"));
        assert!(output.contains("PATH #1:"));
    }
}
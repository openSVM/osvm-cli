# OVSM Interpreter Runtime Specification v1.0

**Document Type**: Technical Specification
**Target**: Runtime Implementation
**Language**: OVSM v1.1
**Implementation Language**: Rust

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Execution Model](#execution-model)
4. [Type System](#type-system)
5. [Memory Model](#memory-model)
6. [Tool Execution Framework](#tool-execution-framework)
7. [Error Handling](#error-handling)
8. [Parallel Execution](#parallel-execution)
9. [AI Integration](#ai-integration)
10. [Security & Sandboxing](#security--sandboxing)
11. [Performance Requirements](#performance-requirements)
12. [Testing Requirements](#testing-requirements)

---

## 1. Overview

### 1.1 Purpose

The OVSM Interpreter is a runtime system that executes OVSM language programs generated by AI agents for blockchain research and analysis.

### 1.2 Key Characteristics

- **Interpreted**: No compilation step, direct AST evaluation
- **Hybrid execution**: Combines deterministic execution with AI decision-making
- **Tool-oriented**: Primary abstraction is external tool invocation
- **Research-focused**: Optimized for data analysis workflows
- **Solana-native**: Built-in support for Solana RPC and blockchain concepts

### 1.3 Design Goals

1. **Correctness**: Faithfully execute OVSM semantics
2. **Performance**: Handle large-scale blockchain data efficiently
3. **Safety**: Prevent resource exhaustion and infinite loops
4. **Observability**: Detailed execution tracing and logging
5. **Extensibility**: Easy to add new tools and capabilities

### 1.4 Non-Goals

- JIT compilation or optimization
- OVSM-to-native code generation
- Interactive REPL (initially)
- IDE integration (initially)

---

## 2. Architecture

### 2.1 High-Level Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    OVSM Interpreter                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌──────────┐    ┌──────────┐    ┌───────────────┐   │
│  │  Parser  │───▶│Validator │───▶│  Evaluator    │   │
│  └──────────┘    └──────────┘    └───────────────┘   │
│       │                                   │            │
│       ▼                                   ▼            │
│  ┌──────────┐                    ┌───────────────┐   │
│  │   AST    │                    │ Runtime State │   │
│  └──────────┘                    └───────────────┘   │
│                                           │            │
│                                           ▼            │
│  ┌─────────────────────────────────────────────────┐  │
│  │            Tool Execution Layer                 │  │
│  ├─────────────────────────────────────────────────┤  │
│  │  Standard Library │ Solana RPC │ Agent Tools   │  │
│  └─────────────────────────────────────────────────┘  │
│                          │                             │
│                          ▼                             │
│  ┌─────────────────────────────────────────────────┐  │
│  │         External Systems                        │  │
│  ├─────────────────────────────────────────────────┤  │
│  │  Solana Nodes │ AI Models │ Databases │ Web    │  │
│  └─────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 2.2 Core Components

#### 2.2.1 Lexer
- Tokenizes OVSM source code
- Handles keywords, identifiers, literals, operators
- Preserves location information for error reporting

#### 2.2.2 Parser
- Builds Abstract Syntax Tree (AST) from tokens
- Validates syntax correctness
- Outputs structured AST for evaluation

#### 2.2.3 Validator
- Semantic validation (before execution)
- Tool availability checking
- Type checking (if type annotations present)
- Detects obviously infinite loops

#### 2.2.4 Evaluator
- Traverses and executes AST
- Manages execution context and variable scopes
- Handles control flow (branches, loops)
- Invokes tools and processes results

#### 2.2.5 Tool Registry
- Maintains catalog of available tools
- Maps tool names to implementations
- Validates tool signatures and parameters
- Provides tool documentation and metadata

#### 2.2.6 Runtime State
- Execution context (variables, constants)
- Call stack for nested scopes
- Execution statistics and metrics
- Resource usage tracking

### 2.3 Component Interactions

```
Source Code
    │
    ▼
[Lexer] ──▶ Tokens
    │
    ▼
[Parser] ──▶ AST
    │
    ▼
[Validator] ──▶ Validated AST
    │
    ▼
[Evaluator]
    │
    ├─▶ [Tool Registry] ──▶ [External Tools]
    │
    ├─▶ [AI Integration] ──▶ [AI Model API]
    │
    └─▶ [Runtime State] ──▶ Results
```

---

## 3. Execution Model

### 3.1 Execution Phases

#### Phase 1: Parsing
```
Input: OVSM source string
Process:
  1. Lexical analysis (tokenization)
  2. Syntax parsing (AST construction)
  3. Syntax validation
Output: Abstract Syntax Tree
```

#### Phase 2: Validation
```
Input: AST
Process:
  1. Semantic validation
  2. Tool existence checking
  3. Type consistency checking (optional)
  4. Constant value resolution
Output: Validated AST + Tool Dependencies
```

#### Phase 3: Preparation
```
Input: Validated AST
Process:
  1. Initialize runtime state
  2. Load and register tools
  3. Set up execution limits
  4. Initialize AI connection (if needed)
Output: Execution Context
```

#### Phase 4: Execution
```
Input: AST + Execution Context
Process:
  1. Evaluate Main Branch
  2. Handle Decision Points (may invoke AI)
  3. Execute selected branches
  4. Process errors and retries
  5. Manage parallel execution
Output: Final Result + Execution Metadata
```

### 3.2 AST Node Types

```rust
pub enum AstNode {
    // Literals
    IntLiteral(i64),
    FloatLiteral(f64),
    StringLiteral(String),
    BoolLiteral(bool),
    NullLiteral,

    // Collections
    ArrayLiteral(Vec<AstNode>),
    ObjectLiteral(Vec<(String, AstNode)>),
    TupleLiteral(Vec<AstNode>),

    // Variables
    Variable(String),
    ConstantDef(String, AstNode),
    Assignment(String, AstNode),
    Destructure(Pattern, AstNode),

    // Operators
    BinaryOp(BinOp, Box<AstNode>, Box<AstNode>),
    UnaryOp(UnOp, Box<AstNode>),
    TernaryOp(Box<AstNode>, Box<AstNode>, Box<AstNode>),
    OptionalChain(Box<AstNode>, Vec<String>),
    NullCoalesce(Box<AstNode>, Box<AstNode>),

    // Control Flow
    If(Box<AstNode>, Vec<AstNode>, Option<Vec<AstNode>>),
    While(Box<AstNode>, Vec<AstNode>),
    For(String, Box<AstNode>, Vec<AstNode>),
    LoopEvery(Duration, Vec<AstNode>),
    Break(Option<Box<AstNode>>),
    Continue,
    Return(Option<Box<AstNode>>),

    // Decision Logic
    Decision(String, Vec<Branch>),
    Branch(String, Box<AstNode>, Vec<AstNode>),
    Guard(Box<AstNode>, Vec<AstNode>),
    Match(Box<AstNode>, Vec<MatchArm>),

    // Error Handling
    Try(Vec<AstNode>, Vec<CatchClause>),
    Catch(ErrorType, Vec<AstNode>),
    Timeout(Duration, Vec<AstNode>),
    Retry(u32, Vec<AstNode>, Option<Vec<Duration>>),
    CircuitBreaker(u32, Duration, Vec<AstNode>),

    // Tool Invocation
    ToolCall(String, Vec<Argument>),
    DefineTool(String, ToolSignature, Vec<AstNode>),
    Define(String, Vec<String>, Vec<AstNode>),

    // Parallel Execution
    Parallel(Vec<AstNode>),
    WaitAll,
    WaitAny,
    Race,

    // Advanced
    SpawnAgent(AgentConfig),
    KnowledgeGraph(GraphOp),
    Hypothesis(HypothesisTest),

    // Meta
    Block(Vec<AstNode>),
    Program(ProgramMetadata, Vec<AstNode>),
}
```

### 3.3 Evaluation Strategy

**Strategy**: Tree-walking interpreter with environment-based scoping

#### 3.3.1 Expression Evaluation
```
evaluate(node: AstNode, env: &mut Environment) -> Result<Value> {
    match node {
        IntLiteral(n) => Ok(Value::Int(n)),
        Variable(name) => env.get(name),
        BinaryOp(op, left, right) => {
            let l = evaluate(left, env)?;
            let r = evaluate(right, env)?;
            apply_binop(op, l, r)
        },
        ToolCall(name, args) => {
            let tool = registry.get_tool(name)?;
            let arg_values = args.map(|a| evaluate(a, env)?);
            tool.invoke(arg_values)
        },
        // ... more patterns
    }
}
```

#### 3.3.2 Statement Execution
```
execute(node: AstNode, env: &mut Environment) -> Result<ExecutionResult> {
    match node {
        Assignment(name, expr) => {
            let value = evaluate(expr, env)?;
            env.set(name, value);
            Ok(ExecutionResult::Continue)
        },
        If(cond, then_block, else_block) => {
            let cond_val = evaluate(cond, env)?;
            if cond_val.as_bool()? {
                execute_block(then_block, env)
            } else if let Some(else_b) = else_block {
                execute_block(else_b, env)
            }
        },
        Return(value) => {
            let val = if let Some(v) = value {
                evaluate(v, env)?
            } else {
                Value::Null
            };
            Ok(ExecutionResult::Return(val))
        },
        // ... more patterns
    }
}
```

### 3.4 Scope Management

```rust
pub struct Environment {
    scopes: Vec<Scope>,
    constants: HashMap<String, Value>,
}

pub struct Scope {
    variables: HashMap<String, Value>,
    parent: Option<usize>,
}

impl Environment {
    fn enter_scope(&mut self) {
        let parent_idx = self.scopes.len() - 1;
        self.scopes.push(Scope {
            variables: HashMap::new(),
            parent: Some(parent_idx),
        });
    }

    fn exit_scope(&mut self) {
        self.scopes.pop();
    }

    fn get(&self, name: &str) -> Result<Value> {
        // Check constants first
        if let Some(val) = self.constants.get(name) {
            return Ok(val.clone());
        }

        // Walk scope chain from innermost to outermost
        let mut scope_idx = self.scopes.len() - 1;
        loop {
            let scope = &self.scopes[scope_idx];
            if let Some(val) = scope.variables.get(name) {
                return Ok(val.clone());
            }
            match scope.parent {
                Some(parent) => scope_idx = parent,
                None => return Err(Error::UndefinedVariable(name.to_string())),
            }
        }
    }

    fn set(&mut self, name: String, value: Value) {
        let current_scope = self.scopes.last_mut().unwrap();
        current_scope.variables.insert(name, value);
    }
}
```

---

## 4. Type System

### 4.1 Runtime Type System

OVSM uses **dynamic typing** with runtime type checking.

#### 4.1.1 Core Types

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    // Primitives
    Null,
    Bool(bool),
    Int(i64),
    Float(f64),
    String(String),

    // Collections
    Array(Vec<Value>),
    Object(HashMap<String, Value>),
    Tuple(Vec<Value>),

    // Blockchain-specific
    Pubkey(Pubkey),
    Signature(Signature),
    Lamports(u64),

    // Complex types
    Transaction(Box<TransactionData>),
    Block(Box<BlockData>),
    Account(Box<AccountData>),

    // Function types
    Function(FunctionDef),
    BuiltinTool(ToolRef),

    // Agent types
    AgentHandle(AgentId),
    AgentResult(Box<AgentResultData>),

    // Graph types
    KnowledgeGraph(Box<GraphData>),

    // Meta
    Range(i64, i64),
    Duration(std::time::Duration),
    Timestamp(chrono::DateTime<chrono::Utc>),
}
```

#### 4.1.2 Type Conversions

```rust
impl Value {
    pub fn as_bool(&self) -> Result<bool> {
        match self {
            Value::Bool(b) => Ok(*b),
            Value::Int(n) => Ok(*n != 0),
            Value::Null => Ok(false),
            _ => Err(Error::TypeError("Cannot convert to bool")),
        }
    }

    pub fn as_int(&self) -> Result<i64> {
        match self {
            Value::Int(n) => Ok(*n),
            Value::Float(f) => Ok(*f as i64),
            Value::String(s) => s.parse().map_err(|_| Error::ParseError),
            _ => Err(Error::TypeError("Cannot convert to int")),
        }
    }

    pub fn as_array(&self) -> Result<&Vec<Value>> {
        match self {
            Value::Array(arr) => Ok(arr),
            _ => Err(Error::TypeError("Expected array")),
        }
    }

    // ... more converters
}
```

#### 4.1.3 Type Checking (Optional Annotations)

When type annotations are present in OVSM code, validate at runtime:

```rust
pub enum TypeAnnotation {
    Any,
    Null,
    Bool,
    Number,  // Int or Float
    String,
    Array(Box<TypeAnnotation>),
    Object(HashMap<String, TypeAnnotation>),
    Union(Vec<TypeAnnotation>),
    Optional(Box<TypeAnnotation>),
    Custom(String),  // Transaction, Block, etc.
}

fn check_type(value: &Value, annotation: &TypeAnnotation) -> Result<()> {
    match (value, annotation) {
        (_, TypeAnnotation::Any) => Ok(()),
        (Value::Null, TypeAnnotation::Null) => Ok(()),
        (Value::Null, TypeAnnotation::Optional(_)) => Ok(()),
        (Value::Bool(_), TypeAnnotation::Bool) => Ok(()),
        (Value::Int(_) | Value::Float(_), TypeAnnotation::Number) => Ok(()),
        (Value::Array(arr), TypeAnnotation::Array(elem_type)) => {
            for elem in arr {
                check_type(elem, elem_type)?;
            }
            Ok(())
        },
        (_, TypeAnnotation::Union(types)) => {
            for t in types {
                if check_type(value, t).is_ok() {
                    return Ok(());
                }
            }
            Err(Error::TypeError("Value doesn't match any union type"))
        },
        _ => Err(Error::TypeError("Type mismatch")),
    }
}
```

### 4.2 Special Types

#### 4.2.1 Blockchain Types

```rust
pub struct TransactionData {
    pub signature: Signature,
    pub slot: u64,
    pub block_time: Option<i64>,
    pub meta: TransactionMeta,
    pub message: Message,
}

pub struct BlockData {
    pub slot: u64,
    pub blockhash: Hash,
    pub parent_slot: u64,
    pub transactions: Vec<TransactionData>,
    pub rewards: Vec<Reward>,
    pub block_time: Option<i64>,
}

pub struct AccountData {
    pub pubkey: Pubkey,
    pub lamports: u64,
    pub owner: Pubkey,
    pub data: Vec<u8>,
    pub executable: bool,
    pub rent_epoch: u64,
}
```

---

## 5. Memory Model

### 5.1 Heap Allocation Strategy

- **Variables**: Stored in scope-based hash maps
- **Large values** (arrays, objects): Stored on Rust heap via `Box` or `Arc`
- **Constants**: Shared via `Arc` (immutable, reference-counted)

### 5.2 Garbage Collection

**Strategy**: Reference counting with cycle detection

```rust
use std::sync::Arc;

pub enum ManagedValue {
    Owned(Value),
    Shared(Arc<Value>),
}

impl ManagedValue {
    pub fn clone_or_share(&self) -> Self {
        match self {
            ManagedValue::Owned(v) if v.is_large() => {
                ManagedValue::Shared(Arc::new(v.clone()))
            },
            ManagedValue::Owned(v) => ManagedValue::Owned(v.clone()),
            ManagedValue::Shared(arc) => ManagedValue::Shared(arc.clone()),
        }
    }
}
```

### 5.3 Memory Limits

Prevent unbounded memory growth:

```rust
pub struct MemoryTracker {
    pub allocated: AtomicUsize,
    pub max_allowed: usize,
}

impl MemoryTracker {
    pub fn allocate(&self, size: usize) -> Result<()> {
        let current = self.allocated.fetch_add(size, Ordering::SeqCst);
        if current + size > self.max_allowed {
            self.allocated.fetch_sub(size, Ordering::SeqCst);
            Err(Error::OutOfMemory)
        } else {
            Ok(())
        }
    }

    pub fn deallocate(&self, size: usize) {
        self.allocated.fetch_sub(size, Ordering::SeqCst);
    }
}
```

---

## 6. Tool Execution Framework

### 6.1 Tool Interface

```rust
pub trait Tool: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn signature(&self) -> &ToolSignature;

    fn execute(
        &self,
        args: ToolArguments,
        context: &ExecutionContext,
    ) -> Result<Value>;

    fn is_async(&self) -> bool {
        false
    }

    fn estimated_cost(&self) -> f64 {
        0.0
    }

    fn can_fail(&self) -> bool {
        true
    }
}

pub struct ToolSignature {
    pub params: Vec<Parameter>,
    pub returns: TypeAnnotation,
    pub variadic: bool,
}

pub struct Parameter {
    pub name: String,
    pub type_annotation: TypeAnnotation,
    pub required: bool,
    pub default: Option<Value>,
}

pub struct ToolArguments {
    pub positional: Vec<Value>,
    pub named: HashMap<String, Value>,
}
```

### 6.2 Tool Registry

```rust
pub struct ToolRegistry {
    tools: HashMap<String, Arc<dyn Tool>>,
    categories: HashMap<String, Vec<String>>,
}

impl ToolRegistry {
    pub fn register<T: Tool + 'static>(&mut self, tool: T) {
        let name = tool.name().to_string();
        self.tools.insert(name.clone(), Arc::new(tool));
    }

    pub fn get(&self, name: &str) -> Result<Arc<dyn Tool>> {
        self.tools.get(name)
            .cloned()
            .ok_or_else(|| Error::UndefinedTool(name.to_string()))
    }

    pub fn list_tools(&self) -> Vec<String> {
        self.tools.keys().cloned().collect()
    }

    pub fn find_by_category(&self, category: &str) -> Vec<String> {
        self.categories.get(category)
            .cloned()
            .unwrap_or_default()
    }
}
```

### 6.3 Tool Invocation

```rust
async fn invoke_tool(
    tool: Arc<dyn Tool>,
    args: ToolArguments,
    context: &ExecutionContext,
) -> Result<Value> {
    // Validate arguments
    validate_arguments(&tool.signature(), &args)?;

    // Track execution
    context.metrics.tool_calls.fetch_add(1, Ordering::Relaxed);
    let start = Instant::now();

    // Execute
    let result = if tool.is_async() {
        tool.execute(args, context).await?
    } else {
        tool.execute(args, context)?
    };

    // Record metrics
    context.metrics.record_tool_execution(
        tool.name(),
        start.elapsed(),
        tool.estimated_cost(),
    );

    Ok(result)
}
```

### 6.4 Standard Library Implementation

Each standard library tool is implemented as a struct:

```rust
pub struct MapTool;

impl Tool for MapTool {
    fn name(&self) -> &str { "MAP" }

    fn description(&self) -> &str {
        "Apply function to each element of collection"
    }

    fn signature(&self) -> &ToolSignature {
        &ToolSignature {
            params: vec![
                Parameter {
                    name: "collection".to_string(),
                    type_annotation: TypeAnnotation::Array(Box::new(TypeAnnotation::Any)),
                    required: true,
                    default: None,
                },
                Parameter {
                    name: "fn".to_string(),
                    type_annotation: TypeAnnotation::Function,
                    required: true,
                    default: None,
                },
            ],
            returns: TypeAnnotation::Array(Box::new(TypeAnnotation::Any)),
            variadic: false,
        }
    }

    fn execute(
        &self,
        args: ToolArguments,
        context: &ExecutionContext,
    ) -> Result<Value> {
        let collection = args.get_positional(0)?.as_array()?;
        let func = args.get_positional(1)?;

        let mut results = Vec::with_capacity(collection.len());
        for item in collection {
            let result = apply_function(func, vec![item.clone()], context)?;
            results.push(result);
        }

        Ok(Value::Array(results))
    }
}
```

### 6.5 Async Tool Execution

```rust
#[async_trait]
pub trait AsyncTool: Send + Sync {
    async fn execute_async(
        &self,
        args: ToolArguments,
        context: &ExecutionContext,
    ) -> Result<Value>;
}

pub struct GetBlockTool {
    rpc_client: Arc<RpcClient>,
}

#[async_trait]
impl AsyncTool for GetBlockTool {
    async fn execute_async(
        &self,
        args: ToolArguments,
        context: &ExecutionContext,
    ) -> Result<Value> {
        let slot = args.get_named("slot")?.as_int()? as u64;

        let block = self.rpc_client
            .get_block(slot)
            .await
            .map_err(|e| Error::RpcError(e))?;

        Ok(Value::Block(Box::new(BlockData::from(block))))
    }
}
```

---

## 7. Error Handling

### 7.1 Error Types

```rust
#[derive(Debug, Clone, thiserror::Error)]
pub enum Error {
    // Parse errors
    #[error("Syntax error at line {line}, column {col}: {message}")]
    SyntaxError { line: usize, col: usize, message: String },

    #[error("Parse error: {0}")]
    ParseError(String),

    // Runtime errors
    #[error("Undefined variable: {0}")]
    UndefinedVariable(String),

    #[error("Undefined tool: {0}")]
    UndefinedTool(String),

    #[error("Type error: {0}")]
    TypeError(String),

    #[error("Division by zero")]
    DivisionByZero,

    #[error("Index out of bounds: {index} for array of length {length}")]
    IndexOutOfBounds { index: usize, length: usize },

    // Tool errors
    #[error("Tool execution failed: {tool} - {reason}")]
    ToolExecutionError { tool: String, reason: String },

    #[error("Invalid arguments for tool {tool}: {reason}")]
    InvalidArguments { tool: String, reason: String },

    // Resource errors
    #[error("Timeout after {0:?}")]
    Timeout(Duration),

    #[error("Out of memory (limit: {0} bytes)")]
    OutOfMemory(usize),

    #[error("Execution limit exceeded (max: {0} operations)")]
    ExecutionLimitExceeded(usize),

    // Control flow (not really errors)
    #[error("Break statement outside loop")]
    InvalidBreak,

    #[error("Continue statement outside loop")]
    InvalidContinue,

    #[error("Return value: {0:?}")]
    ReturnValue(Value),

    // External errors
    #[error("RPC error: {0}")]
    RpcError(String),

    #[error("AI service error: {0}")]
    AiServiceError(String),

    #[error("Network error: {0}")]
    NetworkError(String),

    // User-defined
    #[error("User error: {0}")]
    UserError(String),
}

impl Error {
    pub fn classify(&self) -> ErrorSeverity {
        match self {
            Error::DivisionByZero => ErrorSeverity::Fatal,
            Error::OutOfMemory(_) => ErrorSeverity::Fatal,
            Error::SyntaxError { .. } => ErrorSeverity::Fatal,

            Error::ToolExecutionError { .. } => ErrorSeverity::Recoverable,
            Error::RpcError(_) => ErrorSeverity::Recoverable,
            Error::NetworkError(_) => ErrorSeverity::Recoverable,
            Error::Timeout(_) => ErrorSeverity::Recoverable,

            Error::TypeError(_) => ErrorSeverity::Warning,
            Error::IndexOutOfBounds { .. } => ErrorSeverity::Warning,

            _ => ErrorSeverity::Recoverable,
        }
    }
}

pub enum ErrorSeverity {
    Fatal,
    Recoverable,
    Warning,
}
```

### 7.2 TRY-CATCH Implementation

```rust
fn execute_try_catch(
    try_block: Vec<AstNode>,
    catch_clauses: Vec<CatchClause>,
    env: &mut Environment,
) -> Result<Value> {
    // Execute try block
    match execute_block(&try_block, env) {
        Ok(result) => Ok(result),
        Err(error) => {
            // Find matching catch clause
            for clause in catch_clauses {
                if clause.matches(&error) {
                    // Execute catch handler
                    return execute_block(&clause.body, env);
                }
            }
            // No handler found, propagate error
            Err(error)
        }
    }
}

pub struct CatchClause {
    pub error_type: Option<ErrorType>,
    pub body: Vec<AstNode>,
}

impl CatchClause {
    fn matches(&self, error: &Error) -> bool {
        match &self.error_type {
            None => true,  // Catch all
            Some(ErrorType::Fatal) => error.classify() == ErrorSeverity::Fatal,
            Some(ErrorType::Recoverable) => error.classify() == ErrorSeverity::Recoverable,
            Some(ErrorType::Warning) => error.classify() == ErrorSeverity::Warning,
        }
    }
}
```

### 7.3 Circuit Breaker

```rust
pub struct CircuitBreaker {
    state: Arc<Mutex<CircuitState>>,
    failure_threshold: u32,
    reset_timeout: Duration,
}

enum CircuitState {
    Closed { failures: u32 },
    Open { opened_at: Instant },
    HalfOpen,
}

impl CircuitBreaker {
    pub async fn call<F, T>(&self, f: F) -> Result<T>
    where
        F: FnOnce() -> Result<T>,
    {
        let mut state = self.state.lock().await;

        match *state {
            CircuitState::Open { opened_at } => {
                if opened_at.elapsed() > self.reset_timeout {
                    *state = CircuitState::HalfOpen;
                } else {
                    return Err(Error::CircuitOpen);
                }
            },
            _ => {}
        }

        drop(state);

        match f() {
            Ok(result) => {
                let mut state = self.state.lock().await;
                *state = CircuitState::Closed { failures: 0 };
                Ok(result)
            },
            Err(err) => {
                let mut state = self.state.lock().await;
                match *state {
                    CircuitState::Closed { failures } => {
                        let new_failures = failures + 1;
                        if new_failures >= self.failure_threshold {
                            *state = CircuitState::Open {
                                opened_at: Instant::now(),
                            };
                        } else {
                            *state = CircuitState::Closed {
                                failures: new_failures,
                            };
                        }
                    },
                    CircuitState::HalfOpen => {
                        *state = CircuitState::Open {
                            opened_at: Instant::now(),
                        };
                    },
                    _ => {}
                }
                Err(err)
            }
        }
    }
}
```

---

## 8. Parallel Execution

### 8.1 Parallel Block Execution

```rust
use tokio::task::JoinSet;

async fn execute_parallel(
    statements: Vec<AstNode>,
    wait_strategy: WaitStrategy,
    env: &Environment,
) -> Result<Vec<Value>> {
    let mut join_set = JoinSet::new();

    for stmt in statements {
        let env_clone = env.clone();
        join_set.spawn(async move {
            evaluate_async(stmt, &env_clone).await
        });
    }

    match wait_strategy {
        WaitStrategy::WaitAll => {
            let mut results = Vec::new();
            while let Some(result) = join_set.join_next().await {
                results.push(result??);
            }
            Ok(results)
        },

        WaitStrategy::WaitAny => {
            if let Some(result) = join_set.join_next().await {
                // Cancel remaining tasks
                join_set.abort_all();
                Ok(vec![result??])
            } else {
                Err(Error::NoTasksCompleted)
            }
        },

        WaitStrategy::Race => {
            if let Some(result) = join_set.join_next().await {
                join_set.abort_all();
                Ok(vec![result??])
            } else {
                Err(Error::NoTasksCompleted)
            }
        },
    }
}

pub enum WaitStrategy {
    WaitAll,
    WaitAny,
    Race,
}
```

### 8.2 Thread Safety

All shared state must be thread-safe:

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct SharedEnvironment {
    inner: Arc<RwLock<Environment>>,
}

impl Clone for SharedEnvironment {
    fn clone(&self) -> Self {
        SharedEnvironment {
            inner: Arc::clone(&self.inner),
        }
    }
}

impl SharedEnvironment {
    pub async fn get(&self, name: &str) -> Result<Value> {
        let env = self.inner.read().await;
        env.get(name)
    }

    pub async fn set(&self, name: String, value: Value) {
        let mut env = self.inner.write().await;
        env.set(name, value);
    }
}
```

---

## 9. AI Integration

### 9.1 AI Integration Points

The interpreter calls AI services at specific decision points:

1. **DECISION Point Evaluation**: Choose which branch to execute
2. **AI_DECISION Blocks**: Let AI infer user intent
3. **Dynamic Planning**: Replan when execution fails
4. **Hypothesis Generation**: Generate sub-questions

### 9.2 AI Service Interface

```rust
#[async_trait]
pub trait AiService: Send + Sync {
    async fn make_decision(
        &self,
        decision: &DecisionPoint,
        context: &ExecutionContext,
    ) -> Result<String>;  // Returns branch name

    async fn generate_plan(
        &self,
        question: &str,
        available_tools: &[String],
    ) -> Result<String>;  // Returns OVSM code

    async fn explain_result(
        &self,
        result: &Value,
        target_audience: &str,
    ) -> Result<String>;
}

pub struct OpenAiService {
    api_key: String,
    model: String,
    system_prompt: String,
}

#[async_trait]
impl AiService for OpenAiService {
    async fn make_decision(
        &self,
        decision: &DecisionPoint,
        context: &ExecutionContext,
    ) -> Result<String> {
        let prompt = format!(
            "Decision: {}\n\nBranches:\n{}\n\nCurrent state:\n{}",
            decision.description,
            format_branches(&decision.branches),
            format_context(context),
        );

        let response = self.call_api(&prompt).await?;
        parse_branch_selection(&response)
    }

    // ... other methods
}
```

### 9.3 Decision Point Execution

```rust
async fn execute_decision(
    decision: DecisionPoint,
    ai_service: &dyn AiService,
    env: &mut Environment,
) -> Result<Value> {
    // Build execution context
    let context = ExecutionContext {
        variables: env.snapshot(),
        tool_results: env.get_tool_history(),
        original_question: env.get_metadata("original_question"),
    };

    // Ask AI which branch to execute
    let selected_branch = ai_service
        .make_decision(&decision, &context)
        .await?;

    // Find and execute branch
    for branch in decision.branches {
        if branch.name == selected_branch {
            return execute_block(&branch.body, env);
        }
    }

    Err(Error::InvalidBranchSelection(selected_branch))
}
```

---

## 10. Security & Sandboxing

### 10.1 Execution Limits

```rust
pub struct ExecutionLimits {
    pub max_execution_time: Duration,
    pub max_memory_bytes: usize,
    pub max_tool_calls: usize,
    pub max_loop_iterations: usize,
    pub max_recursion_depth: usize,
    pub max_parallel_tasks: usize,
}

impl Default for ExecutionLimits {
    fn default() -> Self {
        ExecutionLimits {
            max_execution_time: Duration::from_secs(300),  // 5 minutes
            max_memory_bytes: 1_000_000_000,  // 1 GB
            max_tool_calls: 10_000,
            max_loop_iterations: 100_000,
            max_recursion_depth: 100,
            max_parallel_tasks: 100,
        }
    }
}
```

### 10.2 Resource Tracking

```rust
pub struct ResourceTracker {
    start_time: Instant,
    limits: ExecutionLimits,
    metrics: ExecutionMetrics,
}

impl ResourceTracker {
    pub fn check_limits(&self) -> Result<()> {
        // Time limit
        if self.start_time.elapsed() > self.limits.max_execution_time {
            return Err(Error::Timeout(self.limits.max_execution_time));
        }

        // Memory limit
        if self.metrics.memory_used.load(Ordering::Relaxed) > self.limits.max_memory_bytes {
            return Err(Error::OutOfMemory(self.limits.max_memory_bytes));
        }

        // Tool call limit
        if self.metrics.tool_calls.load(Ordering::Relaxed) > self.limits.max_tool_calls {
            return Err(Error::TooManyToolCalls);
        }

        Ok(())
    }
}
```

### 10.3 Infinite Loop Prevention

```rust
fn execute_loop(
    condition: &AstNode,
    body: &[AstNode],
    env: &mut Environment,
    tracker: &ResourceTracker,
) -> Result<Value> {
    let mut iterations = 0;

    loop {
        // Check limits
        tracker.check_limits()?;

        // Check iteration limit
        iterations += 1;
        if iterations > tracker.limits.max_loop_iterations {
            return Err(Error::TooManyIterations);
        }

        // Evaluate condition
        let cond_val = evaluate(condition, env)?;
        if !cond_val.as_bool()? {
            break;
        }

        // Execute body
        match execute_block(body, env)? {
            ExecutionResult::Break => break,
            ExecutionResult::Continue => continue,
            ExecutionResult::Return(val) => return Ok(val),
            ExecutionResult::Continue => {},
        }
    }

    Ok(Value::Null)
}
```

---

## 11. Performance Requirements

### 11.1 Throughput Targets

- **Simple queries**: < 100ms end-to-end
- **Blockchain queries**: < 5 seconds (network-dependent)
- **Statistical analysis**: < 30 seconds for 10,000 data points
- **Parallel execution**: Linear scaling up to 10 concurrent tasks

### 11.2 Memory Efficiency

- **Baseline overhead**: < 10 MB for empty interpreter
- **Per-variable overhead**: < 100 bytes
- **Large arrays**: O(n) memory with lazy evaluation where possible
- **Tool result caching**: LRU cache with configurable size

### 11.3 Optimization Strategies

#### 11.3.1 AST Optimization (Future)
- Constant folding
- Dead code elimination
- Inline small functions

#### 11.3.2 Execution Optimization
```rust
// Cache frequently used values
pub struct ValueCache {
    cache: LruCache<String, Arc<Value>>,
}

impl ValueCache {
    pub fn get_or_compute<F>(
        &mut self,
        key: String,
        compute: F,
    ) -> Arc<Value>
    where
        F: FnOnce() -> Value,
    {
        if let Some(val) = self.cache.get(&key) {
            Arc::clone(val)
        } else {
            let val = Arc::new(compute());
            self.cache.put(key, Arc::clone(&val));
            val
        }
    }
}
```

#### 11.3.3 Tool Call Batching
```rust
// Batch multiple similar RPC calls
pub struct BatchedRpcClient {
    pending: Vec<RpcRequest>,
    batch_size: usize,
}

impl BatchedRpcClient {
    pub async fn batch_get_blocks(&mut self, slots: Vec<u64>) -> Result<Vec<Block>> {
        // Group requests into batches
        let batches = slots.chunks(self.batch_size);

        // Execute batches in parallel
        let mut results = Vec::new();
        for batch in batches {
            let batch_results = self.execute_batch(batch).await?;
            results.extend(batch_results);
        }

        Ok(results)
    }
}
```

---

## 12. Testing Requirements

### 12.1 Unit Tests

- **Lexer tests**: All token types, edge cases
- **Parser tests**: All syntax constructs, error cases
- **Evaluator tests**: Every AST node type
- **Tool tests**: Each standard library tool
- **Error handling tests**: All error types and recovery paths

### 12.2 Integration Tests

- **End-to-end execution**: Full OVSM programs
- **Multi-tool workflows**: Complex tool orchestration
- **Parallel execution**: Concurrent task management
- **AI integration**: Mocked AI service responses
- **Resource limits**: Timeout, memory, iteration limits

### 12.3 Property-Based Tests

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_arithmetic_consistency(a in 0i64..1000, b in 1i64..1000) {
        let program = format!("$result = {} / {}", a, b);
        let result = execute_ovsm(&program).unwrap();
        assert_eq!(result.as_int().unwrap(), a / b);
    }

    #[test]
    fn test_array_operations_preserve_length(
        arr in prop::collection::vec(any::<i64>(), 0..100)
    ) {
        let program = format!("$arr = {:?}\n$reversed = REVERSE($arr)", arr);
        let result = execute_ovsm(&program).unwrap();
        assert_eq!(result.as_array().unwrap().len(), arr.len());
    }
}
```

### 12.4 Performance Tests

```rust
#[test]
fn bench_large_array_map() {
    let program = r#"
        $arr = [1..10000]
        $doubled = MAP($arr, x => x * 2)
        RETURN SUM($doubled)
    "#;

    let start = Instant::now();
    let result = execute_ovsm(program).unwrap();
    let elapsed = start.elapsed();

    assert!(elapsed < Duration::from_millis(100));
    assert_eq!(result.as_int().unwrap(), 100010000);
}
```

### 12.5 Fuzz Testing

```rust
use arbitrary::Arbitrary;

#[derive(Debug, Arbitrary)]
struct FuzzInput {
    program: String,
    inputs: Vec<Value>,
}

#[test]
fn fuzz_parser() {
    bolero::check!().for_each(|input: &FuzzInput| {
        // Parser should never panic, only return errors
        let _ = parse_ovsm(&input.program);
    });
}
```

---

## 13. Observability

### 13.1 Execution Metrics

```rust
pub struct ExecutionMetrics {
    pub tool_calls: AtomicUsize,
    pub memory_used: AtomicUsize,
    pub execution_time: AtomicU64,
    pub ai_calls: AtomicUsize,
    pub errors: AtomicUsize,

    pub tool_execution_times: DashMap<String, Vec<Duration>>,
    pub tool_costs: DashMap<String, Vec<f64>>,
}

impl ExecutionMetrics {
    pub fn record_tool_execution(
        &self,
        tool_name: &str,
        duration: Duration,
        cost: f64,
    ) {
        self.tool_execution_times
            .entry(tool_name.to_string())
            .or_insert_with(Vec::new)
            .push(duration);

        self.tool_costs
            .entry(tool_name.to_string())
            .or_insert_with(Vec::new)
            .push(cost);
    }

    pub fn summary(&self) -> MetricsSummary {
        MetricsSummary {
            total_tool_calls: self.tool_calls.load(Ordering::Relaxed),
            total_memory_used: self.memory_used.load(Ordering::Relaxed),
            total_execution_time_ms: self.execution_time.load(Ordering::Relaxed),
            total_ai_calls: self.ai_calls.load(Ordering::Relaxed),
            total_errors: self.errors.load(Ordering::Relaxed),

            slowest_tools: self.get_slowest_tools(5),
            most_expensive_tools: self.get_most_expensive_tools(5),
        }
    }
}
```

### 13.2 Execution Tracing

```rust
pub enum TraceEvent {
    ProgramStart { timestamp: Instant },
    ToolCall { name: String, args: ToolArguments },
    ToolResult { name: String, result: Value, duration: Duration },
    VariableAssignment { name: String, value: Value },
    DecisionPoint { description: String, branches: Vec<String> },
    BranchSelected { branch: String, reason: String },
    Error { error: Error, context: String },
    ProgramEnd { timestamp: Instant, result: Value },
}

pub struct ExecutionTracer {
    events: Vec<TraceEvent>,
    enabled: bool,
}

impl ExecutionTracer {
    pub fn trace(&mut self, event: TraceEvent) {
        if self.enabled {
            self.events.push(event);
        }
    }

    pub fn export_json(&self) -> String {
        serde_json::to_string_pretty(&self.events).unwrap()
    }
}
```

### 13.3 Logging

```rust
use tracing::{info, warn, error, debug};

fn execute_tool_with_logging(
    tool: &dyn Tool,
    args: ToolArguments,
) -> Result<Value> {
    info!(
        tool = tool.name(),
        args = ?args,
        "Executing tool"
    );

    match tool.execute(args) {
        Ok(result) => {
            debug!(
                tool = tool.name(),
                result = ?result,
                "Tool succeeded"
            );
            Ok(result)
        },
        Err(e) => {
            warn!(
                tool = tool.name(),
                error = %e,
                "Tool failed"
            );
            Err(e)
        }
    }
}
```

---

## 14. Appendix: Complete Example

### 14.1 Sample OVSM Program

```ovsm
**Expected Plan:**

[TIME: ~30s] [COST: ~0.001 SOL] [CONFIDENCE: 90%]

**Available Tools:**
From Standard Library:
  - getSlot (Solana RPC)
  - getBlock (Solana RPC)
  - MAP, FILTER, FLATTEN (Data Processing)
  - MEAN, MEDIAN (Statistical)

**Main Branch:**
$current_slot = getSlot()
$blocks = []

FOR $i IN 0..10:
  $block = getBlock(slot: $current_slot - $i)
  $blocks = APPEND(array: $blocks, item: $block)

$all_txs = FLATTEN(collection: MAP($blocks, b => b.transactions))
$fees = MAP(collection: $all_txs, fn: tx => tx.meta.fee)

$mean_fee = MEAN(data: $fees)
$median_fee = MEDIAN(data: $fees)

**Decision Point:** Check distribution
  BRANCH A ($mean_fee > $median_fee * 1.5):
    $result = $median_fee
  BRANCH B ($mean_fee <= $median_fee * 1.5):
    $result = $mean_fee

**Action:**
RETURN {
  average_fee: $result,
  sample_size: COUNT(collection: $fees)
}
```

### 14.2 Expected Execution Flow

```
1. Parse → AST with 15 nodes
2. Validate → Check tools exist (getSlot, getBlock, etc.)
3. Execute Main Branch:
   a. Call getSlot() → 245000000
   b. Initialize $blocks = []
   c. Loop 10 times:
      - Call getBlock(slot: 244999990 + i)
      - Append to $blocks
   d. Flatten transactions → ~5000 transactions
   e. Extract fees → array of integers
   f. Calculate MEAN → 5432
   g. Calculate MEDIAN → 5000
4. Reach Decision Point
5. Call AI service → "Select BRANCH A"
6. Execute BRANCH A:
   a. Assign $result = 5000
7. Evaluate RETURN statement
8. Return Value::Object with average_fee and sample_size
```

---

## 15. Future Extensions

### 15.1 JIT Compilation (Optional)
- Compile hot paths to native code
- Use cranelift or LLVM backend

### 15.2 Interactive REPL
- Line-by-line evaluation
- Variable inspection
- Debugging commands

### 15.3 IDE Support
- Language Server Protocol (LSP) implementation
- Syntax highlighting
- Auto-completion for tools

### 15.4 Distributed Execution
- Distribute parallel tasks across multiple nodes
- Shared state via distributed cache

---

## Version History

**v1.0** (2025-10-10)
- Initial specification
- Core architecture defined
- All major components specified

---

## References

- OVSM Language Specification v1.1
- OVSM Agent Extensions v1.1
- Rust Async Book
- Solana RPC API Documentation

---

**END OF SPECIFICATION**

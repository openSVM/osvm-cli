<div class="doc-content">
    <h1>ğŸ§  OVSM Language</h1>
    <p class="subtitle">Open Versatile S-expression Machine - Production-Ready Common Lisp Dialect</p>

    <div class="info-box">
        <strong>OVSM</strong> is a LISP-1 dialect interpreter with 83% Common Lisp compatibility, designed for blockchain automation, Solana RPC integration, and general-purpose scripting. <strong>100% test coverage</strong> (356/356 tests passing).
    </div>

    <h2>ğŸ“‹ Overview</h2>
    <p>OVSM combines the elegance of LISP with practical blockchain tools, offering 91+ built-in functions including cryptographic operations, map-reduce functional programming, and native Solana integration.</p>

    <div class="feature-grid">
        <div class="feature-card">
            <h3>ğŸ” Blockchain-Native</h3>
            <p>Base58/Base64/Hex encoding, SHA-256/512 hashing, and first-class Solana RPC integration.</p>
        </div>
        <div class="feature-card">
            <h3>ğŸ§  Lazy Field Access</h3>
            <p><strong>NEW!</strong> Automatically searches nested objects - write <code>(get obj "name")</code> instead of <code>(get (get obj "metadata") "name")</code></p>
        </div>
        <div class="feature-card">
            <h3>ğŸ¯ LISP Elegance</h3>
            <p>S-expression syntax, macros with quasiquote, closures, and pattern matching.</p>
        </div>
        <div class="feature-card">
            <h3>ğŸ”„ Map-Reduce Stack</h3>
            <p>28 functional programming functions: map, filter, reduce, find, distinct, group-by, and more.</p>
        </div>
        <div class="feature-card">
            <h3>âœ… Production-Ready</h3>
            <p>100% test coverage, zero unsafe code, comprehensive error handling.</p>
        </div>
    </div>

    <h2>ğŸ’¡ Quick Example</h2>
    <pre class="code-block"><code>;; Analyze Solana transactions with functional programming
(define addresses [
  "ABC...123"
  "DEF...456"
  "GHI...789"
])

;; Filter active wallets with balance > 1000 SOL
(define rich-wallets
  (filter
    (lambda (addr)
      (> (getBalance addr) 1000000000))
    addresses))

;; Extract transaction signatures
(define recent-txs
  (map
    (lambda (addr)
      (getSignaturesForAddress :address addr :limit 10))
    rich-wallets))

;; Group by transaction type
(define by-type
  (group-by
    (flatten recent-txs)
    (lambda (tx) (. tx type))))

(log :message "Analysis complete" :value by-type)</code></pre>

    <h2>ğŸ“š Documentation</h2>
    <ul class="doc-links">
        <li><a href="ovsm/BUILTIN_FUNCTIONS.md" target="_blank">ğŸ“˜ Built-in Functions Glossary</a> - Complete reference for all 91+ functions (32KB)</li>
        <li><a href="ovsm/README_LISP.md" target="_blank">ğŸ“– OVSM Overview</a> - Start here! Introduction and quick examples</li>
        <li><a href="ovsm/OVSM_LISP_SYNTAX_SPEC.md" target="_blank">ğŸ“• LISP Syntax Specification</a> - Complete language reference</li>
        <li><a href="ovsm/llms.txt" target="_blank">ğŸ¤– LLM Reference</a> - LLM-optimized documentation (16KB)</li>
        <li><a href="ovsm/FEATURES_STATUS.md" target="_blank">ğŸ“Š Features Status</a> - 83% Common Lisp compatibility</li>
        <li><a href="ovsm/INDEX.md" target="_blank">ğŸ—‚ï¸ Legacy Documentation</a> - Original OVSM planning language</li>
    </ul>

    <h2>ğŸ¯ Key Features</h2>

    <h3>ğŸ§  Lazy Field Access (NEW!)</h3>
    <div class="info-box" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; margin-bottom: 2rem;">
        <h4 style="color: white; margin-top: 0;">Intelligent Nested Object Access</h4>
        <p>OVSM's lazy field access automatically searches nested objects when a field isn't found at the top level. No need to know the exact structure!</p>

        <div style="background: rgba(0,0,0,0.2); padding: 1rem; border-radius: 4px; margin-top: 1rem;">
            <strong>Before:</strong> Verbose nested access<br>
            <code style="color: #ffeb3b;">(define name (get (get response "metadata") "name"))</code><br><br>

            <strong>After:</strong> Simple lazy access âœ¨<br>
            <code style="color: #76ff03;">(define name (get response "name"))  ;; Finds metadata.name automatically!</code>
        </div>

        <p style="margin-top: 1rem; margin-bottom: 0;"><strong>How it works:</strong> Depth-first recursive search through nested objects, returns first match found. Works with arbitrary nesting depth!</p>
    </div>

    <h3>Core Language (83% Common Lisp)</h3>
    <ul>
        <li><strong>Data Types:</strong> Numbers, strings, booleans, arrays, objects, ranges</li>
        <li><strong>Control Flow:</strong> if, when, unless, cond, case, typecase, while, for, do</li>
        <li><strong>Functions:</strong> defun, lambda, closures, recursion, variadic (&rest)</li>
        <li><strong>Macros:</strong> defmacro, quasiquote (` , ,@), gensym, macroexpand</li>
        <li><strong>Advanced Binding:</strong> let, let* (sequential), flet, labels (recursive)</li>
        <li><strong>Pattern Matching:</strong> case/typecase with multiple patterns</li>
        <li><strong>Multiple Values:</strong> values, multiple-value-bind</li>
        <li><strong>Dynamic Variables:</strong> defvar with special scoping</li>
    </ul>

    <h3>Map-Reduce Functional Programming (28 functions)</h3>
    <div class="two-column">
        <div>
            <ul>
                <li>ğŸ”„ <strong>Core:</strong> map, filter, reduce</li>
                <li>ğŸ” <strong>Search:</strong> find, some, every</li>
                <li>ğŸ“Š <strong>Transform:</strong> flatten, reverse, distinct</li>
                <li>âœ‚ï¸ <strong>Slice:</strong> take, drop, slice, partition</li>
            </ul>
        </div>
        <div>
            <ul>
                <li>ğŸ”— <strong>Combine:</strong> zip, append, cons</li>
                <li>ğŸ“¦ <strong>Extract:</strong> pluck, compact, first, rest, last</li>
                <li>ğŸ“ˆ <strong>Aggregate:</strong> group-by, count-by</li>
                <li>ğŸ”¢ <strong>Utilities:</strong> sort, length, range, nth</li>
            </ul>
        </div>
    </div>

    <h3>Cryptography & Encoding (8 functions)</h3>
    <ul>
        <li><strong>Base58:</strong> encode/decode (Solana address format)</li>
        <li><strong>Base64:</strong> encode/decode (data encoding)</li>
        <li><strong>Hex:</strong> encode/decode (byte arrays)</li>
        <li><strong>Hashing:</strong> SHA-256, SHA-512 (transaction verification)</li>
    </ul>

    <h2>ğŸ“– Function Categories</h2>
    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-value">91+</div>
            <div class="stat-label">Total Functions</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">16</div>
            <div class="stat-label">Categories</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">100%</div>
            <div class="stat-label">Test Coverage</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">.ovsm</div>
            <div class="stat-label">File Extension</div>
        </div>
    </div>

    <h2>ğŸš€ Function Reference</h2>
    <table class="tool-table">
        <thead>
            <tr>
                <th>Category</th>
                <th>Count</th>
                <th>Examples</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Control Flow</strong></td>
                <td>10</td>
                <td>if, when, cond, case, while, for, do</td>
            </tr>
            <tr>
                <td><strong>Variables</strong></td>
                <td>5</td>
                <td>define, set!, setf, const, defvar</td>
            </tr>
            <tr>
                <td><strong>Functions</strong></td>
                <td>7</td>
                <td>defun, lambda, let, let*, flet, labels</td>
            </tr>
            <tr>
                <td><strong>Macros</strong></td>
                <td>4</td>
                <td>defmacro, gensym, macroexpand, eval</td>
            </tr>
            <tr>
                <td><strong>Logical</strong></td>
                <td>3</td>
                <td>not, and, or</td>
            </tr>
            <tr>
                <td><strong>Type Predicates</strong></td>
                <td>10</td>
                <td>null?, int?, string?, array?, object?</td>
            </tr>
            <tr>
                <td><strong>Crypto & Encoding</strong></td>
                <td>8</td>
                <td>base58-encode, sha256, hex-decode</td>
            </tr>
            <tr>
                <td><strong>Strings</strong></td>
                <td>8</td>
                <td>str, split, join, trim, upper, lower</td>
            </tr>
            <tr>
                <td><strong>Math</strong></td>
                <td>15</td>
                <td>+, -, *, /, %, =, <, >, abs, sqrt, pow</td>
            </tr>
            <tr>
                <td><strong>Collections</strong></td>
                <td>28</td>
                <td>map, filter, reduce, find, group-by</td>
            </tr>
            <tr>
                <td><strong>Objects</strong></td>
                <td>3</td>
                <td>get (with lazy field access âœ¨), keys, merge</td>
            </tr>
        </tbody>
    </table>

    <h2>ğŸ“ Learning Path</h2>
    <div class="learning-path">
        <div class="step">
            <div class="step-number">1</div>
            <div class="step-content">
                <h4>Read OVSM Overview</h4>
                <p>5 minutes - Understand LISP syntax and capabilities</p>
            </div>
        </div>
        <div class="step">
            <div class="step-number">2</div>
            <div class="step-content">
                <h4>Explore Built-in Functions</h4>
                <p>30 minutes - Browse the complete glossary</p>
            </div>
        </div>
        <div class="step">
            <div class="step-number">3</div>
            <div class="step-content">
                <h4>Practice with Examples</h4>
                <p>20 minutes - Try factorial, closures, macros</p>
            </div>
        </div>
        <div class="step">
            <div class="step-number">4</div>
            <div class="step-content">
                <h4>Build Blockchain Scripts</h4>
                <p>1-2 hours - Create Solana analysis tools</p>
            </div>
        </div>
    </div>

    <h2>ğŸŒŸ Use Cases</h2>
    <div class="use-cases">
        <div class="use-case-section">
            <h3>âœ… Perfect For:</h3>
            <ul>
                <li>Blockchain data analysis and automation</li>
                <li>Solana transaction investigation</li>
                <li>Functional data transformations</li>
                <li>Cryptographic operations</li>
                <li>Address encoding/decoding</li>
                <li>Custom DSLs in Rust applications</li>
                <li>Learning LISP concepts</li>
            </ul>
        </div>
        <div class="use-case-section">
            <h3>âŒ Not Ideal For:</h3>
            <ul>
                <li>Real-time systems (&lt;1ms latency)</li>
                <li>Direct hardware control</li>
                <li>Large-scale production web apps</li>
                <li>When you need 100% Common Lisp (currently 83%)</li>
            </ul>
        </div>
    </div>

    <h2>ğŸ’» Example: Transaction Hash Verification</h2>
    <pre class="code-block"><code>;; Blockchain address encoding and verification
(define wallet-data "user_wallet_data_12345")

;; Compute hash for verification
(define data-hash (sha256 wallet-data))
(log :message "SHA-256 hash:" :value data-hash)

;; Encode hash in different formats
(define hash-base64 (base64-encode data-hash))
(define hash-hex (hex-encode data-hash))

;; Verify round-trip encoding
(assert (= wallet-data (base64-decode hash-base64))
        "Base64 round-trip failed")

;; Solana address encoding
(define solana-addr (base58-encode wallet-data))
(log :message "Solana address format:" :value solana-addr)

;; Hash stability verification (deterministic)
(define hash2 (sha256 wallet-data))
(assert (= data-hash hash2) "Hash is not deterministic")

(log :message "âœ… All verifications passed")</code></pre>

    <h2>ğŸ’» Example: Lazy Field Access with MCP Responses</h2>
    <pre class="code-block"><code>;; Real-world MCP response structure (typical API response)
(define mcp-response {
  :supply 999859804306166700
  :metadata {
    :name "OSVM.AI"
    :symbol "OVSM"
    :description "AI-powered blockchain investigation"
    :links {
      :website "https://osvm.ai"
      :twitter "@osvm_ai"
    }
  }
})

;; âŒ OLD WAY: Explicit nested path (verbose, error-prone)
(define name-old (get (get mcp-response "metadata") "name"))
(define symbol-old (get (get mcp-response "metadata") "symbol"))
(define website-old (get (get (get mcp-response "metadata") "links") "website"))

;; âœ… NEW WAY: Lazy field access (automatic search)
(define supply (get mcp-response "supply"))      ;; Direct access (fast path)
(define name (get mcp-response "name"))          ;; Finds metadata.name
(define symbol (get mcp-response "symbol"))      ;; Finds metadata.symbol
(define website (get mcp-response "website"))    ;; Finds metadata.links.website

;; Works with any nesting depth!
(define deep-nested {
  :level1 {
    :level2 {
      :level3 {
        :level4 {
          :treasure "found automatically!"
        }
      }
    }
  }
})

(define treasure (get deep-nested "treasure"))  ;; Returns "found automatically!" âœ¨

;; Gracefully handles missing fields
(define missing (get mcp-response "nonexistent"))  ;; Returns null (no error)

(log :message "Token Analysis:" :value {
  :name name
  :symbol symbol
  :supply supply
  :website website
})</code></pre>

    <h2>ğŸ’» Example: Functional Data Pipeline</h2>
    <pre class="code-block"><code>;; Filter-Map-Reduce pipeline for blockchain analysis
(define transactions [
  {:type "swap" :amount 1000 :active true}
  {:type "transfer" :amount 500 :active false}
  {:type "swap" :amount 2000 :active true}
  {:type "mint" :amount 100 :active true}
])

;; Find all active swaps with amount > 1000
(define large-swaps
  (filter
    (lambda (tx)
      (and (= (. tx type) "swap")
           (. tx active)
           (> (. tx amount) 1000)))
    transactions))

;; Extract amounts and calculate total
(define total
  (reduce +
    (map (lambda (tx) (. tx amount)) large-swaps)
    0))

;; Group transactions by type
(define by-type
  (group-by transactions
    (lambda (tx) (. tx type))))

;; Count transactions by type
(define type-counts
  (count-by transactions
    (lambda (tx) (. tx type))))

(log :message "Total large swaps:" :value total)
(log :message "Grouped by type:" :value by-type)
(log :message "Type counts:" :value type-counts)</code></pre>

    <h2>ğŸ”— Quick Links</h2>
    <div class="button-group">
        <a href="ovsm/BUILTIN_FUNCTIONS.md" class="btn btn-primary" target="_blank">Function Glossary</a>
        <a href="ovsm/README_LISP.md" class="btn btn-secondary" target="_blank">Get Started</a>
        <a href="ovsm/OVSM_LISP_SYNTAX_SPEC.md" class="btn btn-secondary" target="_blank">Full Specification</a>
    </div>

    <div class="info-box" style="margin-top: 2rem;">
        <p><strong>Version:</strong> 1.0.0</p>
        <p><strong>Status:</strong> Production-Ready âœ…</p>
        <p><strong>License:</strong> MIT</p>
        <p><strong>Test Coverage:</strong> 100% (356/356 passing)</p>
        <p><strong>Common Lisp:</strong> 83% compatible</p>
        <p><strong>Built-in Functions:</strong> 91+</p>
    </div>

    <blockquote style="margin-top: 2rem; font-style: italic; border-left: 3px solid var(--accent-color); padding-left: 1rem;">
        "Where blockchain meets LISP elegance" - OVSM Language Philosophy
    </blockquote>
</div>
